<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Ascent Mini-Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 20px 0;
            display: flex;
            flex-direction: column;
            /* Stack elements vertically */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #ffffff;
            font-family: 'Roboto Mono', monospace;
            color: #333;
        }

        h1 {
            color: #444;
            margin-bottom: 15px;
            /* Space between title and canvas */
        }

        #canvas-container {
            position: relative;
            border: 2px solid #444;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            /* Prevent canvas from creating scrollbars */
            line-height: 0;
        }

        #game-info {
            margin-top: 20px;
            /* Space between canvas and info */
            text-align: center;
            max-width: 90%;
            /* Ensure text wraps nicely */
        }

        #game-info p {
            margin: 5px 0;
            /* Tighter spacing for info lines */
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"
            }
        }
    </script>
</head>

<body>
    <h1>Bubble Run</h1>
    <div id="canvas-container"></div>

    <div id="game-info">
        <p>Use the <strong>Left &amp; Right Arrow Keys</strong> to steer the bubble.</p>
        <p>Your goal is to score as much as possible by passing through the seaweed rings.</p>
        <p>Watch out! The game resets if your bubble <strong>collides with a thorn</strong>.</p>
        <p>The amount of lines within a zone presents its density. Higher the density harder it is to control the bubble.</p>
    </div>


    <script type="module">
        // Import p5.js for its side-effects (attaching to the window object)
        import 'p5';

        const sketch = (p) => {
            // Game constants
            const ZONE_COUNT = 4;
            const SEAWEED_RINGS_COUNT = 5;
            const THORN_COUNT = 10;
            const TINY_BUBBLE_COUNT = 20;
            const ZONE_BASE_SPEED = 0.5;

            const BUBBLE_MAX_SPEED = 5;
            const BUBBLE_LIFESPAN = 255;

            let bubble; // A single bubble instead of an array
            let seaweedRings = [];
            let zones = [];
            let thorns = [];
            let popParticles = [];
            let ventParticles = []; // Particles for the ocean vent
            let score = 0;
            let time = 0; // A time variable for seaweed animation

            let bubbleCollidedWithThorn = false;

            // Colors for the ocean gradient
            let topColor;
            let bottomColor;

            // --- Game Object Classes ---

            /**
             * The Bubble class manages the state and behavior of a single bubble.
             */
            class Bubble {
                constructor(x, y) {
                    this.position = p.createVector(x, y);
                    this.velocity = p.createVector(0, -2.5);
                    this.acceleration = p.createVector(0, 0);
                    this.radius = 20;
                    this.lifespan = BUBBLE_LIFESPAN;
                    this.maxSpeed = BUBBLE_MAX_SPEED;
                }

                // Applies a force (like a current or player input) to the bubble
                applyForce(force) {
                    this.acceleration.add(force);
                }

                // Updates the bubble's position based on forces
                update() {
                    this.applyForce(p.createVector(0, -0.35)); // Constant upward buoyancy
                    this.velocity.add(this.acceleration);
                    this.velocity.limit(this.maxSpeed);
                    this.position.add(this.velocity);
                    this.acceleration.mult(0); // Reset acceleration
                    this.lifespan -= 0.5;
                }

                // Draws the bubble on the canvas
                display() {
                    p.noStroke();
                    p.fill(200, 225, 255, this.lifespan * 0.5);
                    p.ellipse(this.position.x, this.position.y, this.radius * 2);
                    p.fill(255, 255, 255, this.lifespan * 0.7);
                    p.ellipse(this.position.x - this.radius * 0.2, this.position.y - this.radius * 0.2, this.radius);
                }

                isDead() {
                    return this.position.y < -this.radius || this.lifespan < 0;
                }
            }


            /**
             * Tiny bubbles created on collision.
             */
            class TinyBubble {
                constructor(x, y) {
                    this.position = p.createVector(x, y);
                    this.velocity = p.createVector(p.random(-1.5, 1.5), p.random(-1, -3.5));
                    this.radius = p.random(2, 6);
                    this.lifespan = 255; // Controls the fade out
                }

                update() {
                    this.position.add(this.velocity);
                    this.lifespan -= 6; // Fades out quickly
                }

                display() {
                    p.noStroke();
                    p.fill(220, 240, 255, this.lifespan);
                    p.ellipse(this.position.x, this.position.y, this.radius * 2);
                }

                isDead() {
                    return this.lifespan < 0;
                }
            }
            
            /**
             * Dark particles that rise from the ocean vent.
             */
            class VentParticle {
                 constructor(x, y) {
                    this.position = p.createVector(x, y);
                    // Slower, more erratic upward movement
                    this.velocity = p.createVector(p.random(-0.3, 0.3), p.random(-0.5, -1.5));
                    this.radius = p.random(3, 8);
                    this.lifespan = 255;
                }

                update() {
                    this.position.add(this.velocity);
                    this.lifespan -= 3; // Fade out slowly
                }

                display() {
                    p.noStroke();
                    // Dark, semi-transparent color for a smoky look
                    p.fill(50, 50, 50, this.lifespan * 0.5);
                    p.ellipse(this.position.x, this.position.y, this.radius * 2);
                }
                
                isDead() {
                    return this.lifespan < 0;
                }
            }


            /**
             * The SeaweedRing class manages the rings that grant points.
             */
            class SeaweedRing {
                constructor() {
                    const x = p.random(p.width * 0.1, p.width * 0.9);
                    const y = p.random(p.height * 0.15, p.height * 0.7);
                    this.position = p.createVector(x, y);
                    this.radius = p.random(40, 70);
                    this.scored = false;
                    this.color = p.color(30, 150, 90, 200);
                    this.scoredColor = p.color(255, 215, 0, 150);
                    this.noiseOffset = p.random(1000);
                }

                checkCollision(b) {
                    if (this.scored) return false;
                    const distance = p.dist(this.position.x, this.position.y, b.position.x, b.position.y);
                    if (distance < this.radius) {
                        this.scored = true;
                        score += 10;
                        return true;
                    }
                    return false;
                }

                display() {
                    p.push();
                    p.translate(this.position.x, this.position.y);
                    const c = this.scored ? this.scoredColor : this.color;
                    p.stroke(c);
                    p.strokeWeight(5);
                    p.noFill();
                    p.beginShape();
                    for (let angle = 0; angle < p.TWO_PI; angle += 0.2) {
                        const noiseVal = p.map(p.noise(this.noiseOffset + angle, time * 0.5), 0, 1, -10, 10);
                        const r = this.radius + noiseVal;
                        const x = r * p.cos(angle);
                        const y = r * p.sin(angle);
                        p.vertex(x, y);
                    }
                    p.endShape(p.CLOSE);
                    p.pop();
                }

                update() {
                    this.noiseOffset += 0.005;
                }
            }

            /**
             * The Zone class defines areas with specific water properties.
             */
            class Zone {
                constructor(y, h, density, speed, color) {
                    this.y = y;
                    this.h = h;
                    this.density = density;
                    this.speed = speed;
                    this.color = color;
                    this.currentParticles = [];

                    const numParticles = p.floor(p.map(p.abs(this.density), 0, 0.15, 5, 30));
                    for (let i = 0; i < numParticles; i++) {
                        this.currentParticles.push({
                            x: p.random(p.width),
                            y: p.random(this.y, this.y + this.h)
                        });
                    }
                }

                display() {
                    p.noStroke();
                    p.fill(this.color);
                    p.rect(0, this.y, p.width, this.h);
                    p.stroke(255, 255, 255, 60);
                    p.strokeWeight(1.5);
                    for (const particle of this.currentParticles) {
                        particle.x += this.speed;
                        if (this.speed > 0 && particle.x > p.width) particle.x = -5;
                        else if (this.speed < 0 && particle.x < 0) particle.x = p.width + 5;
                        const lineLength = p.map(p.abs(this.speed), 0, 0.15, 5, 15);
                        p.line(particle.x, particle.y, particle.x + lineLength, particle.y);
                    }
                }

                contains(b) {
                    return (b.position.y > this.y && b.position.y < this.y + this.h);
                }
            }

            /**
             * The Thorn class defines obstacles.
             */
            class Thorn {
                constructor(x, y, size) {
                    this.position = p.createVector(x, y);
                    this.size = size;
                    this.color = p.color(80, 40, 20, 220);
                    this.angle = p.random(p.TWO_PI);
                }

                display() {
                    p.push();
                    p.translate(this.position.x, this.position.y);
                    p.rotate(this.angle);
                    p.fill(this.color);
                    p.noStroke();
                    const half = this.size / 2;
                    p.beginShape();
                    p.vertex(-half, half);
                    p.vertex(0, -half);
                    p.vertex(half, half);
                    p.vertex(0, half * 0.5);
                    p.endShape(p.CLOSE);
                    p.pop();
                }

                handleCollision(bubble) {
                    const d = p.dist(this.position.x, this.position.y, bubble.position.x, bubble.position.y);
                    if (d < this.size / 2 + bubble.radius) {
                        bubbleCollidedWithThorn = true;
                    }
                }
            }


            // --- p5.js Core Functions ---
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth * 0.8, p.windowHeight * 0.7);
                canvas.parent('canvas-container'); // Attach canvas to the container div

                topColor = p.color(50, 150, 200);
                bottomColor = p.color(5, 20, 50);

                bubble = new Bubble(p.width / 2, p.height - 50);
                initSeaweedRingsAndThorns();

                const zoneHeight = p.height / ZONE_COUNT;
                for (let i = 0; i < ZONE_COUNT - 1; i++) {
                    const currentDirection = i % 2 === 0 ? 1 : -1;
                    const y = i * zoneHeight;
                    const density = p.random(0.3, 0.45);
                    const speed = currentDirection * (ZONE_BASE_SPEED + p.random(0.2, 0.4));
                    const zoneColor = p.color(100, 50 + i * 35, 150, 45);
                    zones.push(new Zone(y, zoneHeight, density, speed, zoneColor));
                }
            };

            p.draw = () => {
                time += 0.01;
                drawGradientBackground();
                drawOceanVent(); // Draw the new ocean vent feature

                // Update and display vent particles
                for (let i = ventParticles.length - 1; i >= 0; i--) {
                    const particle = ventParticles[i];
                    particle.update();
                    particle.display();
                    if (particle.isDead()) {
                        ventParticles.splice(i, 1);
                    }
                }

                for (const zone of zones) zone.display();
                handleInput();

                for (const ring of seaweedRings) {
                    ring.update();
                    ring.display();
                    ring.checkCollision(bubble);
                }

                for (const zone of zones) {
                    if (zone.contains(bubble)) {
                        bubble.applyForce(p.createVector(zone.speed, 0));
                        break;
                    }
                }

                for (const thorn of thorns) {
                    thorn.display();
                    thorn.handleCollision(bubble);
                }

                for (let i = popParticles.length - 1; i >= 0; i--) {
                    const particle = popParticles[i];
                    particle.update();
                    particle.display();
                    if (particle.isDead()) popParticles.splice(i, 1);
                }

                bubble.update();
                bubble.display();

                if (bubbleCollidedWithThorn) {
                    for (let i = 0; i < TINY_BUBBLE_COUNT; i++) {
                        popParticles.push(new TinyBubble(bubble.position.x, bubble.position.y));
                    }
                    resetGame(true);
                } else if (bubble.isDead()) {
                    resetGame(false);
                }

                displayScore();
            };

            function initSeaweedRingsAndThorns() {
                thorns = [];
                seaweedRings = [];
                for (let i = 0; i < SEAWEED_RINGS_COUNT; i++) {
                    seaweedRings.push(new SeaweedRing());
                }

                for (let i = 0; i < THORN_COUNT; i++) {
                    let x, y, size, isValidPlacement = false;
                    while (!isValidPlacement) {
                        x = p.random(p.width);
                        y = p.random(0, p.height - (p.height / ZONE_COUNT));
                        size = p.random(20, 35);
                        isValidPlacement = true;
                        for (const ring of seaweedRings) {
                            const distance = p.dist(x, y, ring.position.x, ring.position.y);
                            if (distance < ring.radius + size / 2 + 10) {
                                isValidPlacement = false;
                                break;
                            }
                        }
                    }
                    thorns.push(new Thorn(x, y, size));
                }
            }


            // --- Control and State Functions ---
            function handleInput() {
                let densityFactor = 1;
                for (const zone of zones) {
                    if (zone.contains(bubble)) {
                        densityFactor = 1 - zone.density;
                        break;
                    }
                }
                const force = 2 * densityFactor;
                if (p.keyIsDown(p.LEFT_ARROW)) bubble.applyForce(p.createVector(-force, 0));
                if (p.keyIsDown(p.RIGHT_ARROW)) bubble.applyForce(p.createVector(force, 0));
            }

            function resetGame(isResetScore) {
                if (isResetScore) score = 0;
                bubble = new Bubble(p.width / 2, p.height - 50);
                initSeaweedRingsAndThorns();
                bubbleCollidedWithThorn = false;
            }

            // --- Helper and Visualization Functions ---
            function drawGradientBackground() {
                p.noFill();
                for (let i = 0; i < p.height; i++) {
                    const inter = p.map(i, 0, p.height, 0, 1);
                    const c = p.lerpColor(topColor, bottomColor, inter);
                    p.stroke(c);
                    p.line(0, i, p.width, i);
                }
            }

            // NEW: Function to draw the ocean floor vent
            function drawOceanVent() {
                // Add new smoke particles periodically
                if (p.frameCount % 5 === 0) {
                    ventParticles.push(new VentParticle(p.width / 2 + p.random(-5, 5), p.height - 20));
                }

                p.push();
                p.noStroke();
                p.fill(40, 30, 25); // Dark, rocky color

                // Create a mound shape for the vent
                p.beginShape();
                p.vertex(p.width / 2 - 80, p.height);
                p.curveVertex(p.width / 2 - 80, p.height);
                p.curveVertex(p.width / 2 - 50, p.height - 15);
                p.curveVertex(p.width / 2, p.height - 25);
                p.curveVertex(p.width / 2 + 50, p.height - 15);
                p.curveVertex(p.width / 2 + 80, p.height);
                p.vertex(p.width / 2 + 80, p.height);
                p.endShape(p.CLOSE);
                
                // A darker shape for the vent opening
                p.fill(20, 15, 10);
                p.beginShape();
                p.vertex(p.width / 2 - 20, p.height-18);
                p.curveVertex(p.width / 2 - 20, p.height-18);
                p.curveVertex(p.width / 2, p.height-30);
                p.curveVertex(p.width / 2 + 20, p.height-18);
                p.vertex(p.width / 2 + 20, p.height-18);
                p.endShape(p.CLOSE);

                p.pop();
            }

            function displayScore() {
                p.fill(255);
                p.noStroke();
                p.textSize(32);
                p.textAlign(p.LEFT, p.TOP);
                p.text(`Score: ${score}`, 20, 20);
            }
        };

        // Create the p5 instance and attach it to the container div.
        new p5(sketch, document.getElementById('canvas-container'));
    </script>
</body>

</html>
