<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Frisbee Alley Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;         
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a1a1a; /* Dark background for better contrast */
            font-family: 'Roboto Mono', monospace;
            color: #e0e0e0;
        }

        #canvas-container {
            position: relative;
            border: 2px solid #555; /* Slightly lighter border */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #2c2c2c; /* Alley background */
        }

        #instructions {
            margin-top: 20px;
            font-size: 1em;
            color: #aaa;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: #2c2c2c;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
            }
        }
    </script>

</head>

<body>
    <div id="canvas-container">
    </div>
    <div id="instructions">Click inside the alley to throw the frisbee</div>
    <script type="module">
        import p5 from 'p5';

        const sketch = (p) => {

            let frisbee;
            // Define alley dimensions relative to window size
            const alleyWidth = p.windowWidth * 0.7;
            const alleyHeight = p.windowHeight * 0.5;
            const narrownessFactor = 0.4; // How narrow the alley is relative to its height

            // Physics constants
            const gravity = p.createVector(0, 0.08); // A gentle gravity
            const liftCoefficient = 0.0012; // How much lift is generated by spin
            const dragCoefficient = 0.0002;  // How much air resistance
            const wallDamping = 0.1;      // Energy lost on wall impact

            /**
             * Represents the frisbee, handling its physics and drawing.
             */
            class Frisbee {
                constructor() {
                   this.reset();
                }

                /**
                 * Resets the frisbee to its initial state for a new throw.
                 */
                reset() {
                    this.position = p.createVector(50, p.height / 2);
                    // Initial velocity from the throw
                    const initialThrowSpeed = p.random(9, 13);
                    const initialUpwardVelocity = p.random(-2.5, 2.5);
                    this.velocity = p.createVector(initialThrowSpeed, initialUpwardVelocity);
                    this.acceleration = p.createVector(0, 0);
                    
                    this.mass = 0.175; // Mass in kg (influences acceleration)
                    this.radius = 25;
                    
                    // Spin is crucial for the hover/lift effect
                    this.spin = p.random(20, 30); // Represents angular velocity
                    this.spinDecay = 0.996; // Spin gradually decreases over time
                    this.angle = 0; // For visualizing the spin
                }

                /**
                 * Applies a force vector to the frisbee's acceleration.
                 * @param {p5.Vector} force - The force to apply.
                 */
                applyForce(force) {
                    // Newton's second law: F = m * a  => a = F / m
                    let f = p5.Vector.div(force, this.mass);
                    this.acceleration.add(f);
                }

                /**
                 * Updates the frisbee's state for the current frame.
                 */
                update() {
                    // --- 1. Calculate Physics Forces ---
                    const speed = this.velocity.mag();

                    // Drag Force (Air Resistance): F_drag = -C * v^2 * รป
                    // Opposes the direction of velocity.
                    if (speed > 0) {
                        let dragMagnitude = dragCoefficient * speed * speed;
                        let drag = this.velocity.copy();
                        drag.mult(-1);
                        drag.normalize();
                        drag.mult(dragMagnitude);
                        this.applyForce(drag);
                    }

                    // Lift Force: F_lift is proportional to spin and forward velocity.
                    // In this 2D side-view, lift directly opposes gravity.
                    let liftMagnitude = this.spin * speed * liftCoefficient;
                    let lift = p.createVector(0, -liftMagnitude);
                    this.applyForce(lift);
                    
                    // Gravity Force
                    this.applyForce(gravity);

                    // --- 2. Update Motion (Kinematics) ---
                    this.velocity.add(this.acceleration);
                    this.position.add(this.velocity);
                    this.acceleration.mult(0); // Reset acceleration for the next frame's calculations

                    // --- 3. Update Spin ---
                    this.spin *= this.spinDecay; // Spin decreases over time
                    this.angle += this.spin / 10; // Update visual rotation angle
                }

                /**
                 * Checks for and handles collisions with the alley walls.
                 */
                checkEdges() {
                    // Bounce off top and bottom walls
                    if (this.position.y > p.height - this.radius) {
                        this.position.y = p.height - this.radius;
                        this.velocity.y *= -wallDamping; // Reverse and dampen y-velocity
                    } else if (this.position.y < this.radius) {
                        this.position.y = this.radius;
                        this.velocity.y *= -wallDamping;
                    }

                    // Bounce off the right wall (end of the alley)
                    if (this.position.x > p.width - this.radius) {
                        this.position.x = p.width - this.radius;
                        this.velocity.x *= -wallDamping; // Reverse and dampen x-velocity
                    }
                }
                
                /**
                 * Renders the frisbee on the canvas.
                 */
                display() {
                    p.push();
                    p.translate(this.position.x, this.position.y);
                    p.rotate(this.angle);
                    p.stroke(255, 255, 0); // Bright yellow outline
                    p.strokeWeight(2);
                    p.fill(200, 200, 0, 180); // Semi-transparent yellow fill
                    p.ellipse(0, 0, this.radius * 2, this.radius * 2);
                    // Add a line to show rotation
                    p.stroke(255, 100, 100);
                    p.line(0, 0, this.radius, 0);
                    p.pop();
                }
            }

            /**
             * p5.js setup function. Runs once at the beginning.
             */
            p.setup = () => {
                const canvas = p.createCanvas(alleyWidth, alleyHeight * narrownessFactor);
                canvas.parent('canvas-container');
                frisbee = new Frisbee();
            };

            /**
             * p5.js draw function. Runs in a loop.
             */
            p.draw = () => {
                p.background(44, 44, 44); // Dark grey alley color
                
                // Draw alley walls for visual context
                p.noStroke();
                p.fill(30, 30, 30);
                p.rect(0, 0, p.width, frisbee.radius); // Top wall area
                p.rect(0, p.height - frisbee.radius, p.width, frisbee.radius); // Bottom wall area

                frisbee.update();
                frisbee.checkEdges();
                frisbee.display();
            };

            /**
             * Handles mouse press events to throw the frisbee.
             */
            p.mousePressed = () => {
                // Only reset if the click is within the canvas bounds
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    frisbee.reset();
                }
            };
            
            /**
             * Handles window resize events.
             */
            p.windowResized = () => {
                const newWidth = p.windowWidth * 0.7;
                const newHeight = p.windowHeight * 0.5 * narrownessFactor;
                p.resizeCanvas(newWidth, newHeight);
                frisbee.reset(); // Reset on resize to prevent weird physics
            }
        };

        const container = window.document.getElementById('canvas-container');
        new p5(sketch, container);

    </script>
</body>

</html>
