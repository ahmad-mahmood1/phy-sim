<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zip Line Rescue Mission</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
        }
        /* Custom styles for sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4A90E2;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4A90E2;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
            }
        }
    </script>
</head>

<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl">
        <h1 class="text-2xl md:text-3xl font-bold text-center text-gray-800 mb-2">Urban Rescue: Zip Line Mission</h1>
        <p class="text-center text-gray-600 mb-4">Adjust the anchors, clear the cracked building, and account for wind to create a safe passage!</p>
    </div>

    <!-- Main container for the simulation and controls -->
    <div class="w-full max-w-4xl bg-white rounded-lg shadow-2xl p-4 md:p-6">
        <!-- p5.js canvas will be injected here -->
        <div id="canvas-container" class="relative w-full h-auto aspect-[16/9] rounded-lg overflow-hidden border-2 border-gray-300">
        </div>
        
        <!-- UI Controls -->
        <div id="controls-container" class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
            
            <!-- Anchor Controls -->
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                <label for="anchor1-slider" class="block font-bold text-gray-700">Start Building Anchor Height</label>
                <input type="range" id="anchor1-slider" min="100" max="400" value="350" class="w-full mt-2">
            </div>
            
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                <label for="anchor2-slider" class="block font-bold text-gray-700">Target Building Anchor Height</label>
                <input type="range" id="anchor2-slider" min="100" max="400" value="200" class="w-full mt-2">
            </div>

            <!-- Weather and Actions -->
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                 <label for="wind-slider" class="block font-bold text-gray-700">Wind (<span id="wind-label">0</span> mph)</label>
                <input type="range" id="wind-slider" min="-20" max="20" value="0" step="1" class="w-full mt-2">
            </div>

        </div>
        
        <div class="flex flex-col md:flex-row gap-4 mt-4">
            <button id="launch-button" class="w-full md:w-1/2 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 shadow-md">
                Launch Rescue Cart
            </button>
            <button id="reset-button" class="w-full md:w-1/2 bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 shadow-md">
                Reset Simulation
            </button>
        </div>
    </div>

    <script type="module">
        import p5 from 'p5';

        const sketch = (p) => {
            // --- DOM Elements ---
            const anchor1Slider = document.getElementById('anchor1-slider');
            const anchor2Slider = document.getElementById('anchor2-slider');
            const windSlider = document.getElementById('wind-slider');
            const launchButton = document.getElementById('launch-button');
            const resetButton = document.getElementById('reset-button');
            const windLabel = document.getElementById('wind-label');


            // --- Simulation State & Constants ---
            let cart = null;
            let isSimulating = false;
            let message = "";
            let messageColor = 'black';
            const G = 0.3; // Gravity constant
            const CART_MASS = 10;
            const MAX_TENSION_ANGLE = 5; // degrees. Angle too shallow = zipline snaps
            const MAX_SAFE_SPEED = 5; // Max speed for a safe landing

            // --- Environment Variables ---
            let building1, building2, middleBuilding;
            let anchor1, anchor2;
            let windForce;

            // --- Fire Particle System ---
            class FireParticle {
                constructor(x, y) {
                    this.pos = p.createVector(x, y);
                    this.vel = p.createVector(p.random(-0.5, 0.5), p.random(-0.5, -1.5));
                    this.lifespan = 255;
                    this.size = p.random(12, 22);
                }

                update() {
                    this.pos.add(this.vel);
                    this.lifespan -= 6;
                    this.size *= 0.96;
                }

                isDead() {
                    return this.lifespan < 0;
                }

                display() {
                    p.noStroke();
                    const from = p.color(255, 200, 0, this.lifespan);
                    const to = p.color(255, 50, 0, this.lifespan);
                    const c = p.lerpColor(from, to, p.map(this.pos.y, this.pos.y + 20, this.pos.y, 0, 1));
                    p.fill(c);
                    p.ellipse(this.pos.x, this.pos.y, this.size);
                }
            }

            class FireEffect {
                constructor(x, y) {
                    this.origin = p.createVector(x, y);
                    this.particles = [];
                }

                update() {
                    // Add new particles
                    for (let i = 0; i < 2; i++) {
                        this.particles.push(new FireParticle(this.origin.x + p.random(-5, 5), this.origin.y));
                    }

                    // Update existing particles
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        this.particles[i].update();
                        if (this.particles[i].isDead()) {
                            this.particles.splice(i, 1);
                        }
                    }
                }

                display() {
                    for (let particle of this.particles) {
                        particle.display();
                    }
                }
            }

            // --- The Rescue Cart Class ---
            class Cart {
                constructor(startPos, ziplineVector) {
                    this.pos = startPos.copy();
                    this.vel = 0; // Speed along the zipline vector
                    this.acc = 0;
                    this.mass = CART_MASS;
                    this.zipline = ziplineVector.copy().normalize(); // The direction of travel
                    this.isSafe = false;
                    this.isLost = false;
                    this.history = [];
                }

                applyForces(wind) {
                    // Calculate component of gravity along the zipline
                    const gravityForce = G * this.mass;
                    const angle = this.zipline.heading();
                    const gravityComponent = gravityForce * p.sin(angle);

                    // Calculate component of wind along the zipline
                    const windComponent = wind.dot(this.zipline);
                    
                    // Total acceleration
                    this.acc = (gravityComponent + windComponent) / this.mass;
                }

                update() {
                    if(this.isSafe || this.isLost) return;
                    
                    this.vel += this.acc;
                    
                    // Simple friction
                    this.vel *= 0.995; 

                    const moveVector = this.zipline.copy().mult(this.vel);
                    this.pos.add(moveVector);
                    
                    // Record path for trail effect
                    this.history.push(this.pos.copy());
                    if (this.history.length > 50) {
                        this.history.splice(0, 1);
                    }
                }

                checkStatus() {
                    // Check for safe landing
                    if (this.pos.x >= building2.x) {
                        this.isSafe = true;
                        if (p.abs(this.vel) > MAX_SAFE_SPEED) {
                             message = "CRASH! Too fast on landing!";
                             messageColor = '#E53E3E'; // Red
                        } else {
                             message = "SUCCESS! Citizen rescued!";
                             messageColor = '#38A169'; // Green
                        }
                        this.vel = 0; // Stop movement
                    }

                    // Check for collision with the middle building's bounding box
                    if (this.pos.x > middleBuilding.x && this.pos.x < middleBuilding.x + middleBuilding.w) {
                        if (this.pos.y > middleBuilding.y) {
                            this.isLost = true;
                            message = "CRASH! You hit the cracked building!";
                            messageColor = '#E53E3E';
                            this.vel = 0; // Stop movement
                        }
                    }
                }

                display() {
                    // Draw trail
                    p.beginShape();
                    p.noFill();
                    p.stroke(74, 144, 226, 100);
                    p.strokeWeight(3);
                    this.history.forEach(v => p.vertex(v.x, v.y));
                    p.endShape();
                
                    // Draw cart
                    p.push();
                    p.translate(this.pos.x, this.pos.y);
                    p.fill('#F5A623'); // Cart color
                    p.stroke('#4A4A4A');
                    p.strokeWeight(2);
                    p.rect(-10, -10, 20, 10, 3); // Cart body
                    p.fill('#4A90E2');
                    p.ellipse(0, 0, 15, 15); // Citizen
                    p.pop();
                }
            }

            p.setup = () => {
                const container = document.getElementById('canvas-container');
                const canvas = p.createCanvas(container.offsetWidth, container.offsetHeight);
                canvas.parent(container);
                
                // Initialize environment based on canvas size
                resetSimulation();

                // --- Event Listeners ---
                launchButton.onclick = launchSimulation;
                resetButton.onclick = resetSimulation;
                windSlider.oninput = () => {
                    windLabel.textContent = windSlider.value;
                };
            };
            
            p.windowResized = () => {
                const container = document.getElementById('canvas-container');
                p.resizeCanvas(container.offsetWidth, container.offsetHeight);
                resetSimulation(); // Reset on resize to recalculate positions
            }

            p.draw = () => {
                p.background('#DDEEFF'); // Sky blue
                
                // --- Update values from controls ---
                anchor1.y = p.height - anchor1Slider.value;
                anchor2.y = p.height - anchor2Slider.value;
                const windStrength = windSlider.value / 100; // Scale down for physics
                windForce = p.createVector(windStrength, 0);

                // --- Draw Environment ---
                drawBuildings();
                drawMiddleBuilding();
                drawAnchors();
                drawZipline();
                drawWind();
                
                // --- Simulation Logic ---
                if (isSimulating && cart) {
                    cart.applyForces(windForce);
                    cart.update();
                    cart.checkStatus();
                    cart.display();
                    launchButton.disabled = true;
                } else {
                    launchButton.disabled = false;
                    displayMessage(message, messageColor);
                }
                
                // Display pre-launch warnings
                if (!isSimulating) {
                    // Combine pre-launch checks
                    const ziplineVec = p5.Vector.sub(anchor2, anchor1);
                    const angle = p.abs(p.degrees(ziplineVec.heading()));
                    if (lineRectIntersect(anchor1, anchor2, middleBuilding)) {
                        displayMessage("WARNING: Path blocked by the building!", '#D97706');
                    } else if (angle < MAX_TENSION_ANGLE) {
                         displayMessage("WARNING: Angle too shallow! High tension risk.", '#D97706');
                    } else {
                        // Clear the warning if angle is okay
                        if (message.startsWith("WARNING")) message = "";
                    }
                }
            };

            // --- Drawing Functions ---
            function drawBuildings() {
                p.fill('#8B9AAD'); // Building color
                p.noStroke();
                p.rect(building1.x, building1.y, building1.w, building1.h);
                p.rect(building2.x, building2.y, building2.w, building2.h);
                // Windows
                p.fill('#4A4A4A');
                for (let y = building1.y + 20; y < p.height - 20; y += 40) {
                   p.rect(building1.x + 20, y, 20, 20);
                   p.rect(building1.x + 60, y, 20, 20);
                }
                 for (let y = building2.y + 20; y < p.height - 20; y += 40) {
                   p.rect(building2.x + 20, y, 20, 20);
                   p.rect(building2.x + 60, y, 20, 20);
                }
            }
            
            function drawMiddleBuilding() {
                p.noStroke();
                // Main building structure
                p.fill('#797C80');
                p.rect(middleBuilding.x, middleBuilding.y, middleBuilding.w, middleBuilding.h);

                // Draw windows
                p.fill('#4A4A4A');
                 middleBuilding.windows.forEach(w => {
                    p.rect(w.x, w.y, w.w, w.h);
                });
                
                // Draw pre-generated cracks
                p.noFill();
                p.stroke(50, 50, 50, 200);
                p.strokeWeight(2);
                middleBuilding.cracks.forEach(crackPath => {
                    p.beginShape();
                    crackPath.forEach(pt => p.vertex(pt.x, pt.y));
                    p.endShape();
                });

                // Update and draw fires on top of the cracks
                middleBuilding.fires.forEach(fire => {
                    fire.update();
                    fire.display();
                });
            }

            function drawAnchors() {
                p.fill('#E53E3E');
                p.stroke('white');
                p.strokeWeight(3);
                p.ellipse(anchor1.x, anchor1.y, 20, 20);
                p.ellipse(anchor2.x, anchor2.y, 20, 20);
            }

            function drawZipline() {
                p.strokeWeight(isSimulating ? 4 : 2);
                p.stroke(isSimulating ? '#4A4A4A' : 'rgba(74, 74, 74, 0.5)');
                p.line(anchor1.x, anchor1.y, anchor2.x, anchor2.y);
            }
            
            function drawWind() {
                p.push();
                p.translate(p.width/2, 30);
                p.fill(100);
                p.noStroke();
                p.text(`Wind: ${windSlider.value} mph`, -30, 15);
                
                // Arrow
                p.stroke(100, 150);
                p.strokeWeight(2);
                p.line(0,0, windForce.x * 500, 0);
                p.push();
                p.translate(windForce.x * 500, 0);
                if (windForce.x !== 0) {
                    let angle = windForce.x > 0 ? 0 : p.PI;
                    p.rotate(angle);
                    p.line(0, 0, -10, -5);
                    p.line(0, 0, -10, 5);
                }
                p.pop();
                p.pop();
            }

            function displayMessage(msg, color = 'black') {
                 if (!msg) return;
                 p.push();
                 p.textAlign(p.CENTER, p.CENTER);
                 p.textSize(24);
                 p.fill(color);
                 p.stroke('white');
                 p.strokeWeight(4);
                 p.text(msg, p.width / 2, p.height / 2);
                 p.pop();
            }

            // --- Control Functions ---
            function launchSimulation() {
                const ziplineVec = p5.Vector.sub(anchor2, anchor1);
                const angle = p.abs(p.degrees(ziplineVec.heading()));

                // Check for failure conditions before launch
                if (lineRectIntersect(anchor1, anchor2, middleBuilding)) {
                    message = "FAIL: Zipline goes through building!";
                    messageColor = '#E53E3E';
                    isSimulating = false;
                    return;
                }
                if (anchor1.y > anchor2.y) {
                    message = "FAIL: Cannot go uphill!";
                    messageColor = '#E53E3E';
                    isSimulating = false;
                    return;
                }
                if (angle < MAX_TENSION_ANGLE) {
                    message = "SNAP! The zip line broke under high tension!";
                    messageColor = '#E53E3E';
                    isSimulating = false; // Don't start
                    return;
                }
                
                message = "";
                isSimulating = true;
                cart = new Cart(anchor1, ziplineVec);
            }

            function resetSimulation() {
                isSimulating = false;
                cart = null;
                message = "";

                const buildingWidth = p.width * 0.15;
                building1 = { x: 0, y: p.height * 0.2, w: buildingWidth, h: p.height * 0.8 };
                building2 = { x: p.width - buildingWidth, y: p.height * 0.4, w: buildingWidth, h: p.height * 0.6 };

                const obstacleX = building1.w + p.width * 0.1;
                const obstacleW = p.width - building1.w - building2.w - p.width * 0.2;
                const obstacleH = p.height * 0.25;
                const obstacleY = p.height - obstacleH;
                
                middleBuilding = {
                    x: obstacleX,
                    y: obstacleY,
                    w: obstacleW,
                    h: obstacleH,
                    cracks: [], 
                    windows: [],
                    fires: []
                };

                // Generate windows and randomly select some for fires
                for (let y = middleBuilding.y + 20; y < middleBuilding.y + middleBuilding.h - 20; y += 40) {
                    for (let x = middleBuilding.x + 20; x < middleBuilding.x + middleBuilding.w - 20; x += 40) {
                        const windowRect = {x: x, y: y, w: 20, h: 20};
                       middleBuilding.windows.push(windowRect);
                       if (p.random() < 0.3) { // 30% chance of fire in a window
                           middleBuilding.fires.push(new FireEffect(windowRect.x + windowRect.w / 2, windowRect.y + windowRect.h / 2));
                       }
                    }
                }

                // Generate two major cracks that span the full height
                for (let i = 0; i < 2; i++) {
                    const crackPath = [];
                    let currentPos = p.createVector(middleBuilding.x + p.random(middleBuilding.w * 0.1, middleBuilding.w * 0.9), middleBuilding.y);
                    crackPath.push(currentPos.copy());
                    
                    while(currentPos.y < middleBuilding.y + middleBuilding.h) {
                        const stepX = p.random(-5, 5);
                        const stepY = p.random(5, 15);
                        currentPos.add(stepX, stepY);
                        currentPos.x = p.constrain(currentPos.x, middleBuilding.x, middleBuilding.x + middleBuilding.w);
                        crackPath.push(currentPos.copy());
                    }
                    middleBuilding.cracks.push(crackPath);
                }

                // Generate 2-3 smaller, partial cracks
                const numSmallCracks = p.floor(p.random(2, 4));
                for (let i = 0; i < numSmallCracks; i++) {
                    const crackPath = [];
                    // Start from a random point on the building face
                    let currentPos = p.createVector(p.random(middleBuilding.x, middleBuilding.x + middleBuilding.w), p.random(middleBuilding.y, middleBuilding.y + middleBuilding.h * 0.7));
                    crackPath.push(currentPos.copy());
                    const crackLength = p.random(middleBuilding.h * 0.2, middleBuilding.h * 0.5);
                    const endY = currentPos.y + crackLength;

                    while(currentPos.y < endY) {
                         const stepX = p.random(-4, 4);
                         const stepY = p.random(4, 12);
                         currentPos.add(stepX, stepY);
                         currentPos.x = p.constrain(currentPos.x, middleBuilding.x, middleBuilding.x + middleBuilding.w);
                         if (currentPos.y > middleBuilding.y + middleBuilding.h) break; // Don't let it go past the bottom
                         crackPath.push(currentPos.copy());
                    }
                    middleBuilding.cracks.push(crackPath);
                }

                anchor1 = p.createVector(building1.w, p.height - anchor1Slider.value);
                anchor2 = p.createVector(building2.x, p.height - anchor2Slider.value);
                launchButton.disabled = false;
            }

            // --- Collision Helper ---
            function lineRectIntersect(p1, p2, rect) {
                // check if the line has hit any of the rectangle's sides
                const left =   lineLineIntersect(p1, p2, {x: rect.x, y: rect.y}, {x: rect.x, y: rect.y + rect.h});
                const right =  lineLineIntersect(p1, p2, {x: rect.x + rect.w, y: rect.y}, {x: rect.x + rect.w, y: rect.y + rect.h});
                const top =    lineLineIntersect(p1, p2, {x: rect.x, y: rect.y}, {x: rect.x + rect.w, y: rect.y});
                const bottom = lineLineIntersect(p1, p2, {x: rect.x, y: rect.y + rect.h}, {x: rect.x + rect.w, y: rect.y + rect.h});

                return left || right || top || bottom;
            }

            function lineLineIntersect(p1, p2, p3, p4) {
                const x1 = p1.x, y1 = p1.y;
                const x2 = p2.x, y2 = p2.y;
                const x3 = p3.x, y3 = p3.y;
                const x4 = p4.x, y4 = p4.y;

                const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (den == 0) return false; // Parallel lines

                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;

                return t > 0 && t < 1 && u > 0 && u < 1;
            }

        };

        new p5(sketch, window.document.getElementById('canvas-container'));
    </script>
</body>

</html>
