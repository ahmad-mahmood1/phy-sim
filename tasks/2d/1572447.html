<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zip Line Rescue Mission</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
        }

        /* Custom styles for sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 5px;
        }

        input[type="range"]:disabled {
            opacity: 0.4;
        }

        input[type="range"]:disabled::-webkit-slider-thumb {
            background: #9ca3af;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4A90E2;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4A90E2;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        /* Modal Transitions */
        .modal {
            transition: opacity 0.3s ease-in-out;
        }

        .modal-content {
            transition: transform 0.3s ease-in-out;
        }

        /* Custom styles for tooltips */
        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .group:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Added pulsating animation for the instructions button */
        @keyframes pulse {
            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 0 4px rgba(59, 130, 246, 0.3);
            }

            50% {
                transform: scale(1.1);
                box-shadow: 0 0 12px rgba(59, 130, 246, 0.6);
            }
        }

        #instructions-button {
            animation: pulse 2.5s infinite ease-in-out;
        }

        #canvas-container {
            touch-action: none;
            /* Ensure the container for p5 canvas is sized */
            width: 100%;
            height: 500px;
        }
    </style>
</head>

<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl text-center">
        <h1 class="text-2xl md:text-3xl font-bold text-gray-800 mb-2 inline-block align-middle">Urban Rescue: Zip Line
            Mission (p5.js)</h1>
        <button id="instructions-button"
            class="ml-2 bg-blue-500 hover:bg-blue-600 text-white font-bold w-8 h-8 rounded-full text-lg inline-flex items-center justify-center align-middle transition-transform duration-200 hover:scale-110">
            ?
        </button>
        <p class="text-gray-600 mt-2 mb-4">A new challenge awaits! Can you save the citizens?</p>
    </div>

    <div class="w-full max-w-[70%] bg-white rounded-lg shadow-2xl p-4 md:p-6 relative">
        <div id="canvas-container" class="rounded-lg overflow-hidden border-2 border-gray-300"></div>

        <div id="game-stats-container" class="grid grid-cols-1 sm:grid-cols-3 md:grid-cols-5 gap-4 mt-6 text-center">
            <div class="bg-red-100 p-3 rounded-lg border border-red-200">
                <h3 class="font-bold text-red-800">PREDICTED SPEED</h3>
                <p id="speed-display" class="text-2xl font-bold text-green-600">SAFE</p>
            </div>
            <div class="bg-blue-100 p-3 rounded-lg border border-blue-200">
                <h3 class="font-bold text-blue-800">ROPE MATERIAL</h3>
                <p id="rope-display" class="text-2xl font-bold text-blue-600">0 / 0</p>
            </div>
            <div class="relative group">
                <div class="bg-purple-100 p-3 rounded-lg border border-purple-200 h-full">
                    <h3 class="font-bold text-purple-800">STABILITY</h3>
                    <p id="stability-display" class="text-2xl font-bold text-purple-600">100%</p>
                </div>
                <span
                    class="tooltip-text absolute bottom-full mb-2 w-48 bg-gray-800 text-white text-xs rounded-lg py-2 px-3 z-10 left-1/2 -translate-x-1/2">
                    Affected by wind and rope angle. Low stability increases the chance of the cart derailing.
                    <svg class="absolute text-gray-800 h-2 w-full left-0 top-full" x="0px" y="0px"
                        viewBox="0 0 255 255" xml:space="preserve">
                        <polygon class="fill-current" points="0,0 127.5,127.5 255,0"></polygon>
                    </svg>
                </span>
            </div>
            <div class="bg-green-100 p-3 rounded-lg border border-green-200">
                <h3 class="font-bold text-green-800">WIND</h3>
                <p id="wind-display" class="text-2xl font-bold text-green-600">0 mph</p>
            </div>
            <div class="bg-yellow-100 p-3 rounded-lg border border-yellow-200">
                <h3 class="font-bold text-yellow-800">SCORE</h3>
                <p id="score-display" class="text-2xl font-bold text-yellow-600">0</p>
            </div>
        </div>

        <div id="controls-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 col-span-1">
                <label for="anchor1-slider" class="block font-bold text-gray-700">Start Anchor Height</label>
                <input type="range" id="anchor1-slider" min="100" value="350" class="w-full mt-2">
            </div>
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 col-span-1">
                <label for="anchor2-slider" class="block font-bold text-gray-700">Target Anchor Height</label>
                <input type="range" id="anchor2-slider" min="100" value="200" class="w-full mt-2">
            </div>
        </div>

        <div class="flex flex-col md:flex-row gap-4 mt-4">
            <button id="launch-button"
                class="w-full md:w-1/3 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 shadow-md disabled:bg-gray-400">
                Launch Rescue Cart
            </button>
            <button id="reset-mission-button"
                class="w-full md:w-1/3 bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 shadow-md disabled:bg-gray-400">
                Reset Mission
            </button>
            <button id="new-mission-button"
                class="w-full md:w-1/3 bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 shadow-md">
                New Mission
            </button>
        </div>

        <div id="success-modal"
            class="modal absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center opacity-0 pointer-events-none">
            <div class="modal-content bg-white p-8 rounded-lg shadow-2xl text-center transform scale-90">
                <h2 class="text-3xl font-bold text-green-600 mb-4">SUCCESS!</h2>
                <p class="text-gray-700 mb-2">You rescued the citizens!</p>
                <p class="text-gray-900 mb-6 text-2xl font-bold">Your Score: <span id="modal-score-display">0</span></p>
                <p class="text-gray-600 mb-6">Can you get a higher score by using less rope or improving stability? Try
                    the same mission again!</p>
                <div class="flex flex-col md:flex-row gap-4 justify-center">
                    <button id="modal-retry-mission-button"
                        class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg">
                        Retry Mission
                    </button>
                    <button id="modal-new-mission-button"
                        class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg">
                        Start New Mission
                    </button>
                </div>
            </div>
        </div>

        <div id="instructions-modal"
            class="modal absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center opacity-0 pointer-events-none p-4">
            <div
                class="modal-content bg-white p-6 md:p-8 rounded-lg shadow-2xl text-left transform scale-90 max-w-lg w-full">
                <h2 class="text-xl md:text-2xl font-bold text-blue-800 mb-4">Your Mission Briefing</h2>
                <ul class="list-disc list-inside text-gray-700 space-y-2">
                    <li><strong>Objective:</strong> Create a safe zipline to rescue the citizens from the far building.
                    </li>
                    <li><strong>Controls:</strong> Use the sliders to set the anchor heights for the zipline.</li>
                    <li><strong>Key Factors:</strong>
                        <ul class="list-['-_'] list-inside ml-6 mt-1 space-y-1">
                            <li><strong>Citizen Load:</strong> More citizens add weight, making the cart faster and
                                increasing rope sag. Plan your clearance carefully!</li>
                            <li><strong>Rope Material:</strong> You have a limited amount of rope for each mission.
                                Don't
                                exceed it!</li>
                            <li><strong>Stability:</strong> A low percentage, affected by wind and steep angles, risks
                                the cart derailing!</li>
                            <li><strong>Wind:</strong> Dynamic weather can be a friend or foe. It may slow your cart on
                                a steep slope to prevent a crash, or push it so fast that it becomes dangerous.</li>
                            <li><strong>Arrival Speed:</strong> If the angle is too steep, the cart will crash on
                                landing. Keep an eye on the speed prediction.</li>
                            <li><strong>Tension & Sag:</strong> A shallow angle creates high tension, risking a snap. A
                                steep angle creates more sag - make sure the cart clears the buildings!</li>
                        </ul>
                    </li>
                    <li><strong>Goal:</strong> A successful rescue earns you points!</li>
                </ul>
                <div class="text-right mt-6">
                    <button id="close-instructions-button"
                        class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">
                        Got It!
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script type='module'>
        import p5 from 'p5';

        // Get references to all the interactive HTML elements.
        const canvasContainer = document.getElementById('canvas-container');
        const anchor1Slider = document.getElementById('anchor1-slider');
        const anchor2Slider = document.getElementById('anchor2-slider');
        const launchButton = document.getElementById('launch-button');
        const newMissionButton = document.getElementById('new-mission-button');
        const resetMissionButton = document.getElementById('reset-mission-button');
        const stabilityDisplay = document.getElementById('stability-display');
        const scoreDisplay = document.getElementById('score-display');
        const speedDisplay = document.getElementById('speed-display');
        const ropeDisplay = document.getElementById('rope-display');
        const windDisplay = document.getElementById('wind-display');
        const successModal = document.getElementById('success-modal');
        const modalScoreDisplay = document.getElementById('modal-score-display');
        const modalNewMissionButton = document.getElementById('modal-new-mission-button');
        const modalRetryMissionButton = document.getElementById('modal-retry-mission-button');
        const instructionsModal = document.getElementById('instructions-modal');
        const instructionsButton = document.getElementById('instructions-button');
        const closeInstructionsButton = document.getElementById('close-instructions-button');

        // This function contains the entire p5.js sketch.
        const sketch = (p) => {
            // Game state variables.
            let score = 0;
            let stability = 100;
            let wind = 0;
            let ropeMaterialAvailable = 0;
            let ropeMaterialUsed = 0;
            let citizenCount = 2;
            let initialMissionState = {}; // Stores the starting state of a mission for retries.
            const MIN_TENSION_ANGLE = 5; // The shallowest angle allowed to prevent snapping.

            // Simulation state and physics constants.
            let cart = null;
            let isSimulating = false;
            let message = ""; // On-screen message (e.g., "CRASH!").
            let messageColor = 'black';
            const G = 0.3; // Gravity constant.
            const CART_MASS = 25;
            const CITIZEN_MASS = 10;
            const MAX_SAFE_SPEED = 7.5; // Max speed for a safe landing.
            const BASE_MAX_SAG = 60; // Base sag amount for the rope.

            // Environment objects.
            let building1, building2, middleBuilding;
            let anchor1, anchor2;
            let windForce;
            let windParticles = [];

            // Helper function to calculate rope sag dynamically.
            // Sag is affected by the cart's progress, the angle of the rope, and number of citizens.
            const calculateSag = (progress, angle, numCitizens) => {
                const perCitizenSagIncrease = 0.25; // How much each extra citizen adds to the sag.
                const citizenSagFactor = 1 + p.max(0, numCitizens - 2) * perCitizenSagIncrease;
                const dynamicMaxSag = BASE_MAX_SAG * citizenSagFactor;

                // A steeper angle results in less sag.
                const sagFactor = p.constrain(p.map(angle, 5, 25, 1, 0.2), 0.2, 1);
                const sagAmount = dynamicMaxSag * sagFactor;

                // Use a parabolic equation for a natural hanging shape.
                return sagAmount * (4 * (progress - progress * progress));
            };

            // Helper function to draw a single stick-figure citizen.
            const drawCitizen = (x, y, size) => {
                p.push();
                p.translate(x, y);
                p.scale(size);
                p.fill(255);
                p.stroke(0);
                p.strokeWeight(1 / size);
                p.ellipse(0, -6, 8, 8); // Head
                p.line(0, -2, 0, 5); // Body
                p.line(-4, 0, 4, 0); // Arms
                p.line(0, 5, -3, 10); // Legs
                p.line(0, 5, 3, 10);
                p.pop();
            };

            // Represents a single line particle for the wind effect.
            class WindParticle {
                constructor() {
                    const startX = wind > 0 ? p.random(-50, 0) : p.random(p.width, p.width + 50);
                    this.pos = p.createVector(startX, p.random(0, p.height));
                    this.initialY = this.pos.y;
                    this.len = p.random(35, 60);
                    this.speed = Math.abs(wind) * p.random(0.1, 0.2) + 3;
                    this.alpha = 150;
                    this.waveFrequency = p.random(0.01, 0.05);
                    this.waveAmplitude = p.random(0.5, 2);
                }
                update() {
                    this.pos.x += this.speed * Math.sign(wind); // Move in wind direction
                    this.pos.y = this.initialY + p.sin(this.pos.x * this.waveFrequency) * this.waveAmplitude; // Gentle wave motion
                }
                isOffscreen() {
                    if (wind > 0 && this.pos.x > p.width + this.len) return true;
                    if (wind < 0 && this.pos.x < -this.len) return true;
                    return false;
                }
                display() {
                    p.push();
                    p.stroke(255, this.alpha);
                    p.strokeWeight(1.5);
                    p.line(this.pos.x, this.pos.y, this.pos.x + this.len * Math.sign(wind), this.pos.y);
                    p.pop();
                }
            }

            // Represents a single fire particle for the burning building effect.
            class FireParticle {
                constructor(x, y) {
                    this.pos = p.createVector(x, y);
                    const windEffect = wind * 0.05; // Wind pushes fire
                    this.vel = p.createVector(p.random(-0.5, 0.5) + windEffect, p.random(-0.5, -1.5));
                    this.lifespan = 255;
                    this.size = p.random(12, 22);
                }
                update() {
                    this.pos.add(this.vel);
                    this.lifespan -= 6; // Fade out
                    this.size *= 0.96; // Shrink
                }
                isDead() { return this.lifespan < 0; }
                display() {
                    p.push();
                    p.noStroke();
                    const from = p.color(255, 200, 0);
                    const to = p.color(255, 50, 0);
                    const amount = p.map(this.pos.y, this.pos.y + 20, this.pos.y, 0, 1);
                    const c = p.lerpColor(from, to, amount);
                    c.setAlpha(this.lifespan);
                    p.fill(c);
                    p.ellipse(this.pos.x, this.pos.y, this.size);
                    p.pop();
                }
            }

            // Manages a collection of fire particles to create a fire effect.
            class FireEffect {
                constructor(x, y) {
                    this.origin = p.createVector(x, y);
                    this.particles = [];
                }
                update() {
                    // Add new particles
                    for (let i = 0; i < 2; i++) {
                        this.particles.push(new FireParticle(this.origin.x + p.random(-5, 5), this.origin.y));
                    }
                    // Update and remove dead particles
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        this.particles[i].update();
                        if (this.particles[i].isDead()) {
                            this.particles.splice(i, 1);
                        }
                    }
                }
                display() {
                    for (let particle of this.particles) {
                        particle.display();
                    }
                }
            }

            // Main class for the rescue cart. Handles all physics and game logic during simulation.
            class Cart {
                constructor(startPos, endPos, initialStability, numCitizens) {
                    this.startAnchor = startPos.copy();
                    this.endAnchor = endPos.copy();
                    this.pos = startPos.copy();
                    this.pulleyPos = startPos.copy(); // Position on the straight line between anchors
                    this.vel = 0;
                    this.acc = 0;
                    this.citizenCount = numCitizens;
                    this.mass = CART_MASS + this.citizenCount * CITIZEN_MASS;
                    this.progress = 0; // Distance traveled along the zipline
                    this.ziplineVec = p5.Vector.sub(this.endAnchor, this.startAnchor);
                    this.totalDistance = this.ziplineVec.mag();
                    this.ziplineDir = this.ziplineVec.copy().normalize();
                    this.angle = p.abs(p.degrees(this.ziplineVec.heading()));

                    // Check for failure conditions at launch
                    this.hasSnapped = (ropeMaterialUsed > ropeMaterialAvailable);
                    this.stability = initialStability;
                    this.derailChance = 100 - this.stability;

                    // State flags
                    this.isSafe = false;
                    this.isLost = false;
                    this.isDerailed = false;
                    this.history = []; // Trail behind the cart
                }

                // Calculate forces acting on the cart.
                applyForces(windVec) {
                    const gravityForce = G * this.mass;
                    const gravityComponent = gravityForce * p.sin(p.radians(this.angle));
                    const windComponent = windVec.dot(this.ziplineDir);
                    this.acc = (gravityComponent + windComponent) / this.mass;
                }

                // Update cart's position and state each frame.
                update() {
                    if (this.isSafe || this.isLost) return; // Stop simulation if game is over

                    if (this.hasSnapped && !this.isLost) {
                        this.isLost = true;
                        this.isDerailed = true;
                        message = "FAIL: Not enough rope material!";
                        messageColor = '#E53E3E';
                    }

                    if (this.isDerailed) {
                        this.pos.y += 5; // Fall down
                        this.pulleyPos.y += 5;
                        return;
                    }

                    // Chance to derail based on stability.
                    if (this.derailChance > 50 && p.random(100) < this.derailChance / 100) {
                        this.isDerailed = true;
                        this.isLost = true;
                        message = "DERAILED! The line was too unstable!";
                        messageColor = '#E53E3E';
                        return;
                    }

                    // Standard physics update
                    this.vel += this.acc;
                    this.vel *= 0.995; // Air resistance/friction
                    this.progress += this.vel;

                    // Calculate position along the ideal straight zipline.
                    const progressRatio = p.constrain(this.progress / this.totalDistance, 0, 1);
                    const idealPos = p5.Vector.lerp(this.startAnchor, this.endAnchor, progressRatio);

                    // Add the calculated sag to get the actual visual position.
                    const sag = calculateSag(progressRatio, this.angle, this.citizenCount);
                    this.pulleyPos.x = idealPos.x;
                    this.pulleyPos.y = idealPos.y + sag;

                    this.pos.x = this.pulleyPos.x;
                    this.pos.y = this.pulleyPos.y + 15; // Cart hangs below pulley

                    // Store recent positions for the trail effect.
                    this.history.push(this.pos.copy());
                    if (this.history.length > 50) {
                        this.history.splice(0, 1);
                    }
                }

                // Check for win/loss conditions.
                checkStatus() {
                    if (this.isLost || this.isSafe) return;

                    // Check if the cart has stopped moving before the end.
                    if (this.progress < 1 && this.vel <= 0.01 && this.acc <= 0) {
                        this.isLost = true;
                        message = "STALLED! Cart cannot move on this slope.";
                        messageColor = '#6B7280';
                        this.vel = 0;
                        return;
                    }

                    // Check for successful arrival.
                    if (!this.isSafe && this.progress >= this.totalDistance) {
                        this.isSafe = true;
                        let lastVelocity = this.vel;
                        this.vel = 0;

                        // Check if landing was too fast.
                        if (p.abs(lastVelocity) > MAX_SAFE_SPEED) {
                            this.isLost = true;
                            message = "CRASH! Too fast on landing!";
                            messageColor = '#E53E3E';
                        } else {
                            // Successful rescue! Calculate score.
                            const baseScore = 500;
                            const ropeBonus = (ropeMaterialAvailable - ropeMaterialUsed) * 2;
                            const stabilityBonus = Math.floor(stability) * 5;
                            const citizenBonus = this.citizenCount * 100;
                            score = baseScore + ropeBonus + stabilityBonus + citizenBonus;
                            updateGameUI();
                            showSuccessModal();
                        }
                    }

                    // Check for collision with the middle building.
                    if (this.pos.x > middleBuilding.x && this.pos.x < middleBuilding.x + middleBuilding.w) {
                        // Find the two points on the roof that the cart is between.
                        let p1 = null, p2 = null;
                        for (let i = 0; i < middleBuilding.topPoints.length - 1; i++) {
                            if (this.pos.x >= middleBuilding.topPoints[i].x && this.pos.x <= middleBuilding.topPoints[i + 1].x) {
                                p1 = middleBuilding.topPoints[i];
                                p2 = middleBuilding.topPoints[i + 1];
                                break;
                            }
                        }
                        if (p1 && p2) {
                            // Interpolate to find the exact roof height at the cart's x-position.
                            const roofYAtCartX = p.map(this.pos.x, p1.x, p2.x, p1.y, p2.y);
                            if (this.pos.y + 15 > roofYAtCartX) {
                                this.isLost = true;
                                message = "CRASH! You hit the cracked building!";
                                messageColor = '#E53E3E';
                                this.vel = 0;
                            }
                        }
                    }
                }

                // Draw the cart and its trail.
                display() {
                    p.push();
                    // Draw trail
                    p.noFill();
                    p.stroke('rgba(74, 144, 226, 0.4)');
                    p.strokeWeight(3);
                    p.beginShape();
                    this.history.forEach(v => p.vertex(v.x, v.y));
                    p.endShape();

                    // Draw cart
                    p.stroke('#4A4A4A');
                    p.strokeWeight(2.5);
                    p.line(this.pulleyPos.x, this.pulleyPos.y, this.pos.x, this.pos.y - 10);
                    p.fill('#F5A623');
                    p.quad(this.pos.x - 22, this.pos.y - 10,
                        this.pos.x + 22, this.pos.y - 10,
                        this.pos.x + 18, this.pos.y + 15,
                        this.pos.x - 18, this.pos.y + 15);
                    p.fill('#666');
                    p.stroke('#333');
                    p.ellipse(this.pulleyPos.x, this.pulleyPos.y, 12, 12);

                    // Draw citizens inside the cart
                    const spacing = 40 / (this.citizenCount + 1);
                    for (let i = 0; i < this.citizenCount; i++) {
                        const citizenX = this.pos.x - 20 + (i + 1) * spacing;
                        drawCitizen(citizenX, this.pos.y, 1.2);
                    }
                    p.pop();
                }
            }

            // Drawing functions for scene elements.
            function drawCitizensOnBuilding() {
                if (isSimulating) return; // Hide them once the cart is launched
                const startY = building1.y - 15;
                const startX = building1.w - (citizenCount * 15) - 10;
                for (let i = 0; i < citizenCount; i++) {
                    drawCitizen(startX + i * 15, startY, 1.5);
                }
            }

            function drawBuildings() {
                p.noStroke();
                p.fill('#8B9AAD');
                drawBuilding(building1);
                drawBuilding(building2);
            }

            function drawBuilding(b) {
                p.push();
                p.fill('#8B9AAD');
                p.rect(b.x, b.y, b.w, b.h);
                p.fill('#4A4A4A');

                // Draw windows from the pre-calculated array
                if (b.windows) {
                    b.windows.forEach(w => {
                        p.rect(w.x, w.y, w.w, w.h);
                    });
                }
                // If the building has fires, draw them
                if (b.fires) {
                    b.fires.forEach(fire => {
                        fire.update();
                        fire.display();
                    });
                }
                p.pop();
            }

            function drawMiddleBuilding() {
                p.push();
                p.fill('#797C80');
                p.noStroke();
                // Draw main shape from its top points
                p.beginShape();
                p.vertex(middleBuilding.x, p.height);
                middleBuilding.topPoints.forEach(pt => p.vertex(pt.x, pt.y));
                p.vertex(middleBuilding.x + middleBuilding.w, p.height);
                p.endShape(p.CLOSE);

                // Draw cracks
                p.stroke('rgba(50, 50, 50, 0.8)');
                p.strokeWeight(2);
                p.noFill();
                middleBuilding.cracks.forEach(crackPath => {
                    p.beginShape();
                    crackPath.forEach((pt) => p.vertex(pt.x, pt.y));
                    p.endShape();
                });

                // Draw windows and fires
                p.noStroke();
                p.fill('#4A4A4A');
                middleBuilding.windows.forEach(w => p.rect(w.x, w.y, w.w, w.h));
                middleBuilding.fires.forEach(fire => {
                    fire.update();
                    fire.display();
                });
                p.pop();
            }

            function drawAnchors() {
                p.push();
                p.fill('#E53E3E');
                p.stroke('white');
                p.strokeWeight(3);
                p.ellipse(anchor1.x, anchor1.y, 20, 20);
                p.ellipse(anchor2.x, anchor2.y, 20, 20);
                p.pop();
            }

            function drawZipline() {
                p.push();
                p.strokeWeight(isSimulating ? 4 : 3);
                p.stroke(isSimulating ? '#4A4A4A' : 'rgba(74, 74, 74, 0.5)');
                p.noFill();

                if (isSimulating && cart) {
                    // During simulation, draw the sagging rope.
                    if (!cart.hasSnapped) {
                        p.line(anchor1.x, anchor1.y, cart.pulleyPos.x, cart.pulleyPos.y);
                        p.line(cart.pulleyPos.x, cart.pulleyPos.y, anchor2.x, anchor2.y);
                    }
                } else {
                    // Before simulation, draw a straight line.
                    p.line(anchor1.x, anchor1.y, anchor2.x, anchor2.y);
                }
                p.pop();
            }

            function drawWeatherEffects() {
                if (p.floor(p.random(0, 5)) === 0 && wind !== 0) {
                    if (windParticles.length < 100) {
                        windParticles.push(new WindParticle());
                    }
                }
                for (let i = windParticles.length - 1; i >= 0; i--) {
                    const particle = windParticles[i];
                    particle.update();
                    particle.display();
                    if (particle.isOffscreen()) {
                        windParticles.splice(i, 1);
                    }
                }
            }

            function displayMessage(msg, color = 'black') {
                if (!msg) return;
                p.push();
                p.textAlign(p.CENTER, p.CENTER);
                p.textFont('"Roboto Mono"');
                p.textSize(24);
                p.textStyle(p.BOLD);
                p.stroke('white');
                p.strokeWeight(4);
                p.fill(color);
                p.text(msg, p.width / 2, p.height / 2);
                p.pop();
            };

            // Updates the HTML display elements with current game data.
            function updateGameUI() {
                scoreDisplay.textContent = score;
                stabilityDisplay.textContent = `${Math.floor(stability)}%`;
                const windDirection = wind > 0 ? "-->" : (wind < 0 ? "<--" : "");
                windDisplay.textContent = `${windDirection} ${Math.abs(wind)} mph`;

                const ziplineVec = p5.Vector.sub(anchor2, anchor1);
                ropeMaterialUsed = Math.floor(ziplineVec.mag());
                ropeDisplay.textContent = `${ropeMaterialUsed} / ${ropeMaterialAvailable}`;
                const angle = p.abs(p.degrees(ziplineVec.heading()));

                // Update the predicted speed display based on the angle.
                let speedText = 'SAFE', speedColorClass = 'text-green-600';
                if (angle > 12) { speedText = 'FAST'; speedColorClass = 'text-yellow-600'; }
                if (angle > 20) { speedText = 'RISKY'; speedColorClass = 'text-orange-500'; }
                if (angle > 24) { speedText = 'DANGEROUS'; speedColorClass = 'text-red-600'; }
                if (anchor1.y >= anchor2.y) { speedText = 'STALLED'; speedColorClass = 'text-gray-500'; }

                speedDisplay.textContent = speedText;
                speedDisplay.className = "text-2xl font-bold " + speedColorClass;

                // Apply warning colors to stats.
                stabilityDisplay.classList.toggle('text-red-600', stability < 50);
                stabilityDisplay.classList.toggle('text-purple-600', stability >= 50);
                ropeDisplay.classList.toggle('text-red-600', ropeMaterialUsed > ropeMaterialAvailable);
                ropeDisplay.classList.toggle('text-blue-600', ropeMaterialUsed <= ropeMaterialAvailable);
            }

            function calculateStability(angle) {
                const anglePenalty = angle * 1.2;
                const windPenalty = p.abs(wind) * 1.5;
                stability = p.constrain(100 - anglePenalty - windPenalty, 0, 100);
            }

            // Enables or disables main controls.
            function setControlsEnabled(enabled) {
                launchButton.disabled = !enabled;
                anchor1Slider.disabled = !enabled;
                anchor2Slider.disabled = !enabled;
            }

            // Mission control functions.
            function launchSimulation() {
                setControlsEnabled(false);
                message = "";
                isSimulating = true;
                cart = new Cart(anchor1, anchor2, stability, citizenCount);
            }

            // Resets the mission to its initial state for a retry.
            function resetMission() {
                isSimulating = false;
                cart = null;
                message = "";
                score = 0;
                // Reload from saved initial state
                wind = initialMissionState.wind;
                windParticles = [];
                citizenCount = initialMissionState.citizenCount;
                // Restore building1, including its windows and fires
                building1 = {
                    ...initialMissionState.building1,
                    fires: initialMissionState.building1.fires.map(fire => new FireEffect(fire.origin.x, fire.origin.y))
                };
                building2 = { ...initialMissionState.building2 };
                // Restore middle building, including its fires
                middleBuilding = {
                    ...initialMissionState.middleBuilding,
                    fires: initialMissionState.middleBuilding.fires.map(fire => new FireEffect(fire.origin.x, fire.origin.y))
                };

                ropeMaterialAvailable = initialMissionState.ropeMaterialAvailable;
                anchor1Slider.max = p.height - building1.y;
                anchor2Slider.max = p.height - building2.y;
                const minSliderVal = 100;
                anchor1Slider.value = minSliderVal + (anchor1Slider.max - minSliderVal) * 0.1;
                anchor2Slider.value = minSliderVal + (anchor2Slider.max - minSliderVal) * 0.1;
                anchor1 = p.createVector(building1.w, p.height - anchor1Slider.value);
                anchor2 = p.createVector(building2.x, p.height - anchor2Slider.value);

                setControlsEnabled(true);
                updateGameUI();
            }

            // A helper function that tests different zipline configurations to find a viable one.
            // This ensures that generated missions are always solvable.
            function findOptimalPath(building1, building2, wind) {
                let bestPath = null;
                let bestScore = -Infinity;
                const startX = building1.w;
                const endX = building2.x;
                const deltaX = endX - startX;

                // Iterate through potential start heights and angles.
                for (let y1 = building1.y + 20; y1 < p.height - 50; y1 += 15) {
                    for (let angleDeg = MIN_TENSION_ANGLE; angleDeg < 25; angleDeg += 1) {
                        const angleRad = p.radians(angleDeg);
                        const deltaY = p.tan(angleRad) * deltaX;
                        const y2 = y1 + deltaY;

                        if (y2 < building2.y + 20 || y2 > p.height - 50) continue;

                        const path = { start: p.createVector(startX, y1), end: p.createVector(endX, y2) };

                        // Run a simplified physics simulation to check if this path works.
                        const dynamicMass = CART_MASS + citizenCount * CITIZEN_MASS;
                        const gravityComponent = (G * dynamicMass) * p.sin(angleRad);
                        const windVec = p.createVector(wind / 100, 0);
                        const pathVec = p5.Vector.sub(path.end, path.start).normalize();
                        const windComponent = windVec.dot(pathVec);
                        const acceleration = (gravityComponent + windComponent) / dynamicMass;
                        const distance = p5.Vector.sub(path.end, path.start).mag();

                        if (acceleration <= 0) continue; // Unwinnable path

                        const finalVelocity = p.sqrt(2 * acceleration * distance);
                        const currentStability = 100 - (angleDeg * 1.2) - (p.abs(wind) * 1.5);

                        // If the path is safe, score it to find the "best" one.
                        if (finalVelocity < MAX_SAFE_SPEED && currentStability > 50) {
                            let score = 1000 - distance * 0.5 - (MAX_SAFE_SPEED - finalVelocity) * 20 + currentStability;
                            if (score > bestScore) {
                                bestScore = score;
                                bestPath = path;
                            }
                        }
                    }
                }
                return bestPath;
            }

            // Procedurally generates a new, solvable mission.
            function setupRandomMission() {
                isSimulating = false;
                cart = null;
                message = "";
                score = 0;
                windParticles = [];
                const gapWidth = p.width * 0.72;

                let optimalPath = null;
                let attempts = 0; // Failsafe to prevent infinite loop

                // Keep trying to generate a mission until a solvable path is found
                while (!optimalPath && attempts < 100) {
                    wind = p.floor(p.random(-15, 15)) || 5; // Wind can be from -15 to 15, but not 0.
                    citizenCount = p.floor(p.random(2, 5)); // 2, 3, or 4 citizens.
                    const buildingWidth = p.width * 0.15;
                    const building1Height = p.random(0.88, 0.9);
                    const building2Height = p.random(0.4, 0.89);

                    // Re-initialize buildings in each attempt
                    building1 = { x: 0, y: p.height * (1 - building1Height), w: buildingWidth, h: p.height * building1Height, windows: [], fires: [] };
                    building2 = { x: buildingWidth + gapWidth, y: p.height * (1 - building2Height), w: p.width - (buildingWidth + gapWidth), windows: [], h: p.height * building2Height };

                    // Generate windows for building 1
                    for (let y = building1.y + 20; y < p.height - 20; y += 40) {
                        for (let x = building1.x + 20; x < building1.x + building1.w - 20; x += 40) {
                            building1.windows.push({ x: x, y: y, w: 20, h: 20 });
                        }
                    }

                    // Generate windows for building 2
                    for (let y = building2.y + 20; y < p.height - 20; y += 40) {
                        for (let x = building2.x + 20; x < building2.x + building2.w - 20; x += 40) {
                            building2.windows.push({ x: x, y: y, w: 20, h: 20 });
                        }
                    }

                    optimalPath = findOptimalPath(building1, building2, wind);
                    attempts++;
                }

                if (!optimalPath) {
                    console.error("Failed to generate a solvable mission after 100 attempts. Check generation logic.");
                    // Fallback to a default, likely solvable path to prevent a total crash.
                    optimalPath = { start: p.createVector(building1.w, p.height - 350), end: p.createVector(building2.x, p.height - 200) };
                }

                // Now that a solvable path is found, set up the rest of the mission state.

                // Add fire to ~50% of the windows in building 1
                building1.windows.forEach(w => {
                    if (p.random() < 0.5) {
                        building1.fires.push(new FireEffect(w.x + w.w / 2, w.y + w.h / 2));
                    }
                });

                const safeAnchor1 = optimalPath.start;
                const safeAnchor2 = optimalPath.end;
                const safeZiplineVec = p5.Vector.sub(safeAnchor2, safeAnchor1);
                const safeAngle = p.abs(p.degrees(safeZiplineVec.heading()));

                const maxPossibleRope = p.dist(building1.w, building1.y, building2.x, p.height - 100);
                ropeMaterialAvailable = p.floor(maxPossibleRope * 0.95);

                const obstacleX = building1.w + p.width * 0.05;
                const obstacleW = gapWidth - (p.width * 0.1);
                middleBuilding = { x: obstacleX, y: 0, w: obstacleW, cracks: [], windows: [], fires: [], topPoints: [] };
                const clearanceBuffer = 50; // How much space to leave below the optimal path.
                let lastY = p.height;

                // Generate the middle building's roof to be just below the solvable path.
                for (let x = obstacleX; x <= obstacleX + obstacleW; x += 15) {
                    const progressRatio = p.map(x, safeAnchor1.x, safeAnchor2.x, 0, 1);
                    const idealYatX = p.lerp(safeAnchor1.y, safeAnchor2.y, progressRatio);
                    const sagAtX = calculateSag(progressRatio, safeAngle, citizenCount);
                    const ropeYatX = idealYatX + sagAtX; // This is the lowest point of the rope at this x.
                    const y = (x === obstacleX) ? ropeYatX + clearanceBuffer + p.random(10, 30) : lastY + p.random(-15, 15);
                    const finalY = p.constrain(y, ropeYatX + clearanceBuffer, p.height - 60);
                    middleBuilding.topPoints.push(p.createVector(x, finalY));
                    lastY = finalY;
                }

                // Finish populating the middle building with details.
                middleBuilding.y = middleBuilding.topPoints.reduce((min, pt) => pt.y < min ? pt.y : min, p.height);
                let maxTopPointY = middleBuilding.topPoints.reduce((max, pt) => pt.y > max ? pt.y : max, 0);
                for (let y = maxTopPointY + 20; y < p.height - 20; y += 40) {
                    for (let x = middleBuilding.x + 20; x < middleBuilding.x + middleBuilding.w - 20; x += 40) {
                        const windowRect = { x: x, y: y, w: 20, h: 20 };
                        middleBuilding.windows.push(windowRect);
                        // Add fire to ~50% of the windows
                        if (p.random() < 0.5) {
                            middleBuilding.fires.push(new FireEffect(windowRect.x + windowRect.w / 2, windowRect.y + windowRect.h / 2));
                        }
                    }
                }
                const numCracks = p.floor(p.random(8, 12));
                let prevStartPosition = p.createVector(middleBuilding.x + middleBuilding.w * 0.1, maxTopPointY);
                for (let i = 0; i < numCracks; i++) {
                    let startPos = (i === 0) ? prevStartPosition.copy() : p.createVector(p.min(prevStartPosition.x + p.random(30, 50), middleBuilding.x + middleBuilding.w - 20), prevStartPosition.y + p.random(-5, 5));
                    prevStartPosition = startPos.copy();
                    const crackPath = [startPos.copy()];
                    let currentPos = startPos.copy();
                    const endY = currentPos.y + (p.height - middleBuilding.y) * p.random(0.4, 0.9);
                    while (currentPos.y < endY) {
                        currentPos.add(p.createVector(p.random(-15, 15), p.random(5, 15)));
                        currentPos.x = p.constrain(currentPos.x, middleBuilding.x, middleBuilding.x + middleBuilding.w);
                        crackPath.push(currentPos.copy());
                    }
                    middleBuilding.cracks.push(crackPath);
                }

                // Save this generated mission's state so the user can retry it.
                initialMissionState = {
                    wind, citizenCount,
                    building1: { ...building1, fires: building1.fires.map(f => ({ origin: f.origin.copy() })) },
                    building2: { ...building2 },
                    middleBuilding: { ...middleBuilding, fires: middleBuilding.fires.map(f => ({ origin: f.origin.copy() })) },
                    ropeMaterialAvailable
                };

                resetMission(); // Call reset to apply the newly generated state.
            }

            // Functions to control modal visibility and animations.
            function showModal(modalElement) {
                modalElement.classList.remove('opacity-0', 'pointer-events-none');
                modalElement.querySelector('.modal-content').classList.remove('scale-90');
            }
            function hideModal(modalElement) {
                modalElement.classList.add('opacity-0');
                modalElement.querySelector('.modal-content').classList.add('scale-90');
                setTimeout(() => modalElement.classList.add('pointer-events-none'), 300);
            }
            function showSuccessModal() {
                modalScoreDisplay.textContent = score;
                showModal(successModal);
            }
            const hideSuccessModal = () => hideModal(successModal);
            const showInstructionsModal = () => showModal(instructionsModal);
            const hideInstructionsModal = () => hideModal(instructionsModal);

            // Core p5.js setup function. Runs once.
            p.setup = () => {
                p.createCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
                p.textFont('"Roboto Mono"');

                // Assign functions to button clicks.
                launchButton.onclick = launchSimulation;
                newMissionButton.onclick = setupRandomMission;
                resetMissionButton.onclick = resetMission;
                modalNewMissionButton.onclick = () => { hideSuccessModal(); setupRandomMission(); };
                modalRetryMissionButton.onclick = () => { hideSuccessModal(); resetMission(); };
                instructionsButton.onclick = showInstructionsModal;
                closeInstructionsButton.onclick = hideInstructionsModal;

                // Generate the first mission.
                setupRandomMission();
            };

            // Core p5.js draw function. Runs in a loop.
            p.draw = () => {
                p.background('#f45c5c'); // A reddish sky background

                // Update anchor positions from sliders and calculate wind vector.
                anchor1.y = p.height - anchor1Slider.value;
                anchor2.y = p.height - anchor2Slider.value;
                windForce = p.createVector(wind / 100, 0);

                let warningMsg = "";

                // Before the simulation starts, update UI and check for warnings.
                if (!isSimulating) {
                    setControlsEnabled(true);
                    const ziplineVec = p5.Vector.sub(anchor2, anchor1);
                    const angle = p.abs(p.degrees(ziplineVec.heading()));

                    calculateStability(angle);
                    updateGameUI();

                    if (anchor1.y > anchor2.y) {
                        warningMsg = "WARNING: Upward angle! Cart will not move.";
                        launchButton.disabled = true;
                    } else if (angle < MIN_TENSION_ANGLE) {
                        warningMsg = "WARNING: Angle too shallow, rope may snap!";
                        launchButton.disabled = true; // Specifically disable launch on warning.
                    } else if (ropeMaterialUsed > ropeMaterialAvailable){
                        warningMsg = 'WARNING: Rope material limit exceeded!';
                        launchButton.disabled = true
                    }



                    if (cart && cart.isLost) { // If the last mission failed
                        setControlsEnabled(false);
                    }
                    message = "";
                }


                // Draw all scene elements in order (back to front).
                drawBuildings();
                drawMiddleBuilding();
                drawWeatherEffects();
                drawZipline();
                drawAnchors();
                drawCitizensOnBuilding();

                // If simulating, run the physics and drawing for the cart.
                if (isSimulating && cart) {
                    cart.applyForces(windForce);
                    cart.update();
                    cart.checkStatus();
                    cart.display();
                    // If simulation ends in failure, keep controls disabled.
                    if (cart.isLost) {
                        setControlsEnabled(false);
                    }
                }

                // Display any relevant messages on the screen.
                if (warningMsg && !isSimulating) {
                    displayMessage(warningMsg, '#D97706'); // Orange for warning
                } else {
                    displayMessage(message, messageColor);
                }
            };

            // Handles canvas resizing.
            p.windowResized = () => {
                p.resizeCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
                setupRandomMission(); // Generate a new mission that fits the new size
            };
        };

        // Create a new p5 instance and attach it to the canvas container.
        new p5(sketch, 'canvas-container');
    </script>
</body>

</html>
