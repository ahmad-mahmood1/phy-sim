<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmonograph Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        input[type="range"] {
            width: 90%;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
            }
        }
    </script>
</head>

<body class="bg-white flex justify-center items-center font-mono p-4 relative">

    <div class="flex flex-col gap-2 w-full">
        <h1 class="text-black text-3xl">Harmonograph Simulation</h1>
        <main id="canvas-container" class="w-full h-[700px] flex justify-center items-center bg-slate-100">
        </main>
    </div>

    <div id="controls"
        class='absolute top-2 right-2 flex flex-col items-center gap-4 p-3 w-[30%] bg-slate-800 rounded-lg'>
    </div>

    <script type="module">
        import p5 from "p5";

        // --- P5.JS SKETCH ---
        const sketch = (p) => {
            const TRAIL_PATH_LENGTH = 1000; // Increased for more detailed patterns

            // --- Simulation Constants ---
            const SLIDER_CONFIG = {
                pendulum1: {
                    length: { min: 50, max: 300, default: 200, step: 10 },
                    amplitude: { min: 0.1, max: 1.0, default: 0.8, step: 0.1 },
                    damping: { min: 0.0, max: 0.05, default: 0.001, step: 0.001 }, // Added subtle default damping
                    frequency: 1,
                    phase: { min: 0, max: 2 * Math.PI, default: 0, step: 0.1 } // Added phase control
                },
                pendulum2: {
                    length: { min: 50, max: 300, default: 210, step: 5 }, // Expanded range
                    amplitude: { min: 0.1, max: 1.5, default: 1.0, step: 0.1 }, // Expanded range
                    damping: { min: 0.0, max: 0.05, default: 0.001, step: 0.001 }, // Added subtle default damping
                    frequency: 2,
                    phase: { min: 0, max: 2 * Math.PI, default: Math.PI / 2, step: 0.1 } // Added phase control
                },
                pendulum3: {
                    length: { min: 40, max: 60, default: 50, step: 5 } // Expanded range
                },
                // Configuration for the new fourth pendulum
                pendulum4: {
                    length: { min: 40, max: 60, default: 50, step: 5 }
                }
            };

            // --- State Variables ---
            let t = 0;
            let path = [];
            const pendulums = [];

            // --- Slider Arrays ---
            const lengthSliders = [];
            const amplitudeSliders = [];
            const dampingSliders = [];
            const phaseSliders = []; // Sliders for phase control

            function createControlPanel() {
                const controlsDiv = document.querySelector('#controls');

                for (let i = 0; i < 4; i++) {
                    const pendulumControls = document.createElement('div');
                    let label = '';
                    if (i === 0) label = 'X-Axis';
                    else if (i === 1) label = 'Y-Axis';
                    else if (i === 2) label = 'Rotational 1';
                    else label = 'Rotational 2';

                    pendulumControls.className = 'flex flex-col gap-2 w-full';
                    let innerHTML = `<h3 class="text-white text-lg font-bold mb-2">Pendulum ${i + 1} (${label})</h3>`;

                    // Length Slider (for all pendulums)
                    innerHTML += `
                        <div class="slider-group">
                            <div class="flex justify-between w-full mb-1">
                                <span class="text-white text-sm">Length</span>
                                <span id="p${i}-length-value" class="text-white text-sm"></span>
                            </div>
                            <div id="p${i}-length" class="slider-container"></div>
                        </div>`;

                    // Sliders for Amplitude, Damping, and Phase (only for pendulums 0 and 1)
                    if (i < 2) {
                        innerHTML += `
                            <div class="slider-group">
                                <div class="flex justify-between w-full mb-1">
                                    <span class="text-white text-sm">Amplitude</span>
                                    <span id="p${i}-amp-value" class="text-white text-sm"></span>
                                </div>
                                <div id="p${i}-amp" class="slider-container"></div>
                            </div>
                            <div class="slider-group">
                                <div class="flex justify-between w-full mb-1">
                                    <span class="text-white text-sm">Damping</span>
                                    <span id="p${i}-damp-value" class="text-white text-sm"></span>
                                </div>
                                <div id="p${i}-damp" class="slider-container"></div>
                            </div>
                            <div class="slider-group">
                                <div class="flex justify-between w-full mb-1">
                                    <span class="text-white text-sm">Phase</span>
                                    <span id="p${i}-phase-value" class="text-white text-sm"></span>
                                </div>
                                <div id="p${i}-phase" class="slider-container"></div>
                            </div>`;
                    }

                    pendulumControls.innerHTML = innerHTML;
                    controlsDiv.appendChild(pendulumControls);
                }
            }

            // --- Pendulum Class for driving pendulums (X and Y) ---
            class Pendulum {
                constructor(pivot, defaults) {
                    this.pivot = pivot.copy();
                    this.f = defaults.f; // Frequency
                    this.a = defaults.a; // Amplitude
                    this.l = defaults.l; // Length
                    this.d = defaults.d; // Damping
                    this.p = defaults.p; // Phase
                    this.bob = this.getBobPosition(0);
                }

                getBobPosition(time) {
                    const angle = this.a * Math.sin(this.f * time + this.p) * Math.exp(-this.d * time);
                    const x = this.pivot.x + this.l * Math.sin(angle);
                    const y = this.pivot.y + this.l * Math.cos(angle);
                    return p.createVector(x, y);
                }

                update(time) {
                    this.bob = this.getBobPosition(time);
                }

                draw() {
                    p.stroke(200, 0, 150);
                    p.strokeWeight(1);
                    p.line(this.pivot.x, this.pivot.y, this.bob.x, this.bob.y);
                    p.fill(200, 0, 150);
                    p.noStroke();
                    p.ellipse(this.bob.x, this.bob.y, 20, 20);
                }
            }

            // --- Rotational Pendulum Class using Verlet Integration ---
            class RotationalPendulum {
                constructor(pivot, defaults) {
                    this.pivot = pivot.copy();
                    this.l = defaults.l;
                    this.gravity = p.createVector(0, 0.5);
                    this.damping = 0.998;
                    this.bob = p.createVector(this.pivot.x, this.pivot.y + this.l);
                    this.prevBob = this.bob.copy();
                }

                update(newPivot) {
                    this.pivot = newPivot.copy();
                    let velocity = p5.Vector.sub(this.bob, this.prevBob);
                    velocity.mult(this.damping);
                    this.prevBob = this.bob.copy();
                    this.bob.add(velocity);
                    this.bob.add(this.gravity);

                    let toBob = p5.Vector.sub(this.bob, this.pivot);
                    let currentDist = toBob.mag();
                    let error = currentDist - this.l;
                    toBob.normalize();
                    toBob.mult(-error);
                    this.bob.add(toBob);
                }

                draw(isPen = false) {
                    p.stroke(0);
                    p.strokeWeight(isPen ? 2 : 1);
                    p.line(this.pivot.x, this.pivot.y, this.bob.x, this.bob.y);

                    p.fill(isPen ? 255 : 0);
                    p.stroke(0);
                    p.strokeWeight(1);
                    p.ellipse(this.bob.x, this.bob.y, isPen ? 20 : 15);

                    p.fill(100);
                    p.noStroke();
                    p.ellipse(this.pivot.x, this.pivot.y, 10);
                }
            }

            p.setup = () => {
                const canvasContainer = document.getElementById('canvas-container');
                const w = canvasContainer.offsetWidth;
                const h = canvasContainer.offsetHeight;
                p.createCanvas(w, h).parent('canvas-container');
                p.frameRate(60);

                createControlPanel();

                // Create sliders for each pendulum
                for (let i = 0; i < 4; i++) {
                    const config = SLIDER_CONFIG[`pendulum${i + 1}`];
                    lengthSliders[i] = p.createSlider(config.length.min, config.length.max, config.length.default, config.length.step).parent(`p${i}-length`);

                    if (i < 2) {
                        amplitudeSliders[i] = p.createSlider(config.amplitude.min, config.amplitude.max, config.amplitude.default, config.amplitude.step).parent(`p${i}-amp`);
                        dampingSliders[i] = p.createSlider(config.damping.min, config.damping.max, config.damping.default, config.damping.step).parent(`p${i}-damp`);
                        phaseSliders[i] = p.createSlider(config.phase.min, config.phase.max, config.phase.default, config.phase.step).parent(`p${i}-phase`);
                    }
                }

                // Create pendulums
                pendulums.push(new Pendulum(p.createVector(p.width * 0.45, 10), { ...SLIDER_CONFIG.pendulum1, f: SLIDER_CONFIG.pendulum1.frequency, a: SLIDER_CONFIG.pendulum1.amplitude.default, l: SLIDER_CONFIG.pendulum1.length.default, d: SLIDER_CONFIG.pendulum1.damping.default, p: SLIDER_CONFIG.pendulum1.phase.default }));
                pendulums.push(new Pendulum(p.createVector(p.width * 0.15, 250), { ...SLIDER_CONFIG.pendulum2, f: SLIDER_CONFIG.pendulum2.frequency, a: SLIDER_CONFIG.pendulum2.amplitude.default, l: SLIDER_CONFIG.pendulum2.length.default, d: SLIDER_CONFIG.pendulum2.damping.default, p: SLIDER_CONFIG.pendulum2.phase.default }));
                pendulums.push(new RotationalPendulum(p.createVector(0, 0), { l: SLIDER_CONFIG.pendulum3.length.default }));
                pendulums.push(new RotationalPendulum(p.createVector(0, 0), { l: SLIDER_CONFIG.pendulum4.length.default })); // The new pendulum

                resetDrawing();
            };

            function resetDrawing() {
                t = 0;
                path = [];
                // Reset the rotational pendulums' physics states
                const dynamicPivot = p.createVector(pendulums[0].bob.x, pendulums[1].bob.y);
                pendulums[2] = new RotationalPendulum(dynamicPivot, { l: lengthSliders[2].value() });
                pendulums[3] = new RotationalPendulum(pendulums[2].bob, { l: lengthSliders[3].value() });
                p.loop();
            }

            function updateSliderValues() {
                let sliderChanged = false;
                for (let i = 0; i < 4; i++) {
                    const currentLength = lengthSliders[i].value();
                    if (pendulums[i].l !== currentLength) {
                        sliderChanged = true;
                        pendulums[i].l = currentLength;
                    }
                    document.getElementById(`p${i}-length-value`).textContent = `${currentLength}px`;

                    if (i < 2) {
                        const currentAmp = amplitudeSliders[i].value();
                        const currentDamp = dampingSliders[i].value();
                        const currentPhase = phaseSliders[i].value();

                        if (currentAmp !== pendulums[i].a || currentDamp !== pendulums[i].d || currentPhase !== pendulums[i].p) {
                            sliderChanged = true;
                        }
                        pendulums[i].a = currentAmp;
                        pendulums[i].d = currentDamp;
                        pendulums[i].p = currentPhase;

                        document.getElementById(`p${i}-amp-value`).textContent = `${currentAmp.toFixed(2)}`;
                        document.getElementById(`p${i}-damp-value`).textContent = `${currentDamp.toFixed(3)}`;
                        document.getElementById(`p${i}-phase-value`).textContent = `${currentPhase.toFixed(2)} rad`;
                    }
                }

                if (sliderChanged) {
                    resetDrawing();
                }
            }

            p.draw = () => {
                updateSliderValues();
                p.background(241, 245, 249); // bg-slate-100

                // Draw the harmonograph path
                p.noFill();
                p.strokeWeight(1.5);
                p.stroke(220, 50, 50, 220);
                p.beginShape();
                for (const v of path) {
                    p.vertex(v.x, v.y);
                }
                p.endShape();

                // Update and draw the visible pendulums
                drawVisiblePendulums();

                t += 0.05;
            };

            function drawVisiblePendulums() {
                // Update and draw Pendulums 1 & 2
                pendulums[0].update(t);
                pendulums[0].draw();
                pendulums[1].update(t);
                pendulums[1].draw();

                // The pivot for the first rotational pendulum is driven by the first two
                const dynamicPivot = p.createVector(pendulums[0].bob.x, pendulums[1].bob.y);
                p.fill(150);
                p.noStroke();
                p.ellipse(dynamicPivot.x, dynamicPivot.y, 10, 10); // Draw the pivot

                // Update and draw Pendulum 3
                pendulums[2].update(dynamicPivot);
                pendulums[2].draw();

                // Update and draw Pendulum 4 (The Pen)
                // Its pivot is the bob of Pendulum 3
                pendulums[3].update(pendulums[2].bob);
                pendulums[3].draw(true); // 'true' indicates this is the final pen

                const penTip = pendulums[3].bob;
                path.push({ x: penTip.x, y: penTip.y });
                if (path.length > TRAIL_PATH_LENGTH) {
                    path.shift();
                }
            }
        };

        new p5(sketch);
    </script>
</body>

</html>