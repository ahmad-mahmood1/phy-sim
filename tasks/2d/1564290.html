<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Swaying Tree Animation</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            /* Light grey background */
            overflow: hidden;
            font-family: 'Roboto Mono', monospace;
            /* Hide scrollbars */
        }

        #canvas-container {
            position: relative;
            border: 2px solid #444;
            box-shadow: 0 0 15px #000;
            background-color: #ffffff;
            /* Set canvas container background */
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
            }
        }
    </script>

</head>

<body>
    <h1>Swaying Tree Canopy With Piercing Light Beams</h1>
    <div id="canvas-container">
    </div>
    <script type="module">
        import p5 from 'p5';

        const sketch = (p) => {
            const canvasWidth = 800;
            const canvasHeight = 700;

            const baseLength = 3
            const baseDepth = 4
            const startingBranchLength = 100
            const branchStartYOffset = -startingBranchLength * 1.05

            const beamWidth = 65; // Width of the light beams
            const lightSources = [
                { x: canvasWidth * 0.15, y: startingBranchLength, angle: p.PI / 2.2, opacity: 0 },
                { x: canvasWidth * 0.45, y: startingBranchLength, angle: p.PI / 2.2, opacity: 0 },
                { x: canvasWidth * 0.65, y: startingBranchLength, angle: p.PI / 2.2, opacity: 0 },
                { x: canvasWidth * 0.85, y: startingBranchLength, angle: p.PI / 2.2, opacity: 0 }
            ];

            let particles = [];
            const numParticles = 700; // Adjust as needed
            const particleDriftSpeed = 1; // Speed at which particles move left to right
            const particleYSwayMagnitude = 55; // Max vertical sway distance
            const particleYSwaySpeed = 0.1; // Speed of vertical sway
            const baseParticleOpacity = 10; // Opacity when not in a beam
            const beamParticleOpacityBoost = 255; // Max additional opacity when in a beam

            let time = 0; // Global time variable for noise-based animation

            p.setup = () => {
                // p.createCanvas is used by p5.js to create the drawing surface
                // It's placed in the #canvas-container div by the last lines of this script
                p.createCanvas(canvasWidth, canvasHeight);
                p.frameRate(30); // Set a smooth frame rate

                (function initializeParticles() {
                    particles = []; // Clear existing particles
                    for (let i = 0; i < numParticles; i++) {
                        particles.push({
                            x: p.random(p.width),
                            y: p.random(p.height),
                            initialY: p.random(p.height), // Store initial Y for consistent noise
                            noiseOffsetY: p.random(1000), // Per-particle noise offset for Y sway
                            z: p.random(0.5, 1.5), // For parallax effect (size/speed)
                            opacity: baseParticleOpacity,
                            size: p.random(3, 4)
                        });
                    }
                })()
            };

            p.draw = () => {
                p.background(220, 240, 255); // Light sky blue background


                // --- Gradient Shadow Layer ---
                // This creates a vertical gradient from transparent to semi-transparent black,
                // simulating a general shadow or dimming effect from the canopy downwards.
                let shadowStartY = p.height * 1 / 1e5; // Start shadow roughly where canopy might be dense
                let shadowEndY = p.height;       // Shadow goes to the bottom of the canvas

                p.noStroke(); // No outline for the shadow segments

                // Define the gradient properties
                let topAlpha = 0;    // Alpha at the top of the shadow area (fully transparent)
                let bottomAlpha = 200; // Max alpha at the bottom of the shadow area

                for (let y = shadowStartY; y < shadowEndY; y++) {
                    // Calculate the interpolation factor (0 at shadowStartY, 1 at shadowEndY)
                    let inter = p.map(y, shadowStartY, shadowEndY, 0, 1);
                    // Lerp the alpha value based on the y position
                    let currentAlpha = p.lerp(topAlpha, bottomAlpha, inter);
                    p.fill(0, 0, 0, currentAlpha); // Black with interpolated alpha
                    p.rect(0, y, p.width, 1); // Draw a 1-pixel high rectangle
                }

                // --- Draw Light Beams ---
                drawLightBeams(p);


                // --- Update and Display Particles ---
                updateAndDisplayParticles(p);

                // --- Draw the Swaying Branches ---
                p.strokeCap(p.ROUND); // Use round ends for branches for a softer look

                // Start multiple main branches from the TOP of the canvas, angled downwards.
                drawBranch(p, p.width * 0.1, branchStartYOffset, p.PI / 2, startingBranchLength, 9);
                drawBranch(p, p.width * 0.3, branchStartYOffset, p.PI / 2, startingBranchLength, 9);
                drawBranch(p, p.width * 0.6, branchStartYOffset, p.PI / 2, startingBranchLength, 9);
                drawBranch(p, p.width * 0.75, branchStartYOffset, p.PI / 2, startingBranchLength, 9); // Note: 5*PI/2 is same as PI/2

                time += 0.008; // Increment time to drive the animation
            };


            function drawLightBeams(p) {
                lightSources.forEach((source, i) => {
                    let beamLength = p.height * 1.35;
                    // Flicker effect using noise for opacity for the main beam part
                    let beamOpacity = p.map(p.noise(source.x * 0.01, time * 2), 0, 1, 1, 70);
                    // update beam opacity for later in particle opacity detection
                    lightSources[i].opacity = beamOpacity;

                    p.push();
                    p.stroke(255, 255, 200, beamOpacity); // Light yellow, semi-transparent for main beam
                    p.strokeWeight(beamWidth);

                    // Calculate end point of the main beam segment
                    let mainBeamStartX = source.x;
                    let mainBeamStartY = source.y;
                    let mainBeamEndX = mainBeamStartX + p.cos(source.angle) * beamLength;
                    let mainBeamEndY = mainBeamStartY + p.sin(source.angle) * beamLength;

                    p.line(mainBeamStartX, mainBeamStartY, mainBeamEndX, mainBeamEndY);
                    p.pop();


                    // --- Additional beam segment from top of canvas to the start of the main beam ---
                    let additionalBeamEndY = source.y; // Y-coordinate where this beam segment ends (main beam start)
                    let additionalBeamEndX = source.x; // X-coordinate where this beam segment ends (main beam start)
                    let additionalBeamStartY = 0;      // Y-coordinate where this beam segment starts (top of canvas)
                    let additionalBeamStartX;          // X-coordinate to be calculated

                    // Calculate additionalBeamStartX such that the line from
                    // (additionalBeamStartX, additionalBeamStartY) to (additionalBeamEndX, additionalBeamEndY)
                    // has the angle source.angle.
                    if (Math.abs(p.cos(source.angle)) < 1e-6) {
                        // Angle is nearly vertical (PI/2 or 3PI/2). tan(angle) would be problematic.
                        // For a vertical beam, the x-coordinate remains constant.
                        additionalBeamStartX = additionalBeamEndX;
                    } else {
                        additionalBeamStartX = additionalBeamEndX - (additionalBeamEndY - additionalBeamStartY) / p.tan(source.angle);
                    }

                    p.push();
                    // Using a slightly different opacity or style for this part can be an option
                    p.stroke(255, 255, 190, 100);
                    p.strokeWeight(beamWidth);
                    p.line(additionalBeamStartX, additionalBeamStartY, additionalBeamEndX, additionalBeamEndY);
                    p.pop();
                });
            }


            function updateAndDisplayParticles(p) {
                p.noStroke();
                for (let i = particles.length - 1; i >= 0; i--) {
                    let particle = particles[i];

                    // Update horizontal position (drift left to right, z affects speed slightly)
                    particle.x += particleDriftSpeed * particle.z;
                    if (particle.x > p.width + particle.size * particle.z) { // Adjust wrap-around check for size
                        particle.x = -particle.size * particle.z - 50; // Wrap around with a buffer
                        particle.y = p.random(p.height); // Reset Y position when wrapping for variety
                        particle.initialY = particle.y; // Update initialY as well
                    }

                    // Add Perlin noise for vertical sway
                    let ySway = p.map(
                        p.noise(particle.x * 0.01, particle.noiseOffsetY + time * particleYSwaySpeed),
                        0, 1,
                        -particleYSwayMagnitude, particleYSwayMagnitude
                    );
                    let displayY = particle.y + ySway;

                    // Check for intersection with light beams
                    let inBeam = false;
                    let maxBeamInfluenceOpacity = 0;

                    for (const source of lightSources) {
                        const beamLength = p.height * 1.35; // Same as in drawLightBeams
                        const beamAngle = source.angle;
                        const beamStartX = source.x;
                        const beamStartY = source.y;
                        const beamEndX = beamStartX + p.cos(beamAngle) * beamLength;
                        const beamEndY = beamStartY + p.sin(beamAngle) * beamLength;

                        // Calculate distance from particle to the beam's centerline segment
                        const distToBeam = distToLineSegment(p, particle.x, displayY, beamStartX, beamStartY, beamEndX, beamEndY);

                        if (distToBeam < beamWidth / 2) {
                            inBeam = true;
                            maxBeamInfluenceOpacity = Math.max(maxBeamInfluenceOpacity, source.opacity || 0);
                        }
                    }

                    if (inBeam) {
                        particle.opacity = baseParticleOpacity + p.map(maxBeamInfluenceOpacity, 0, 255, 0, beamParticleOpacityBoost);
                    } else {
                        particle.opacity = p.lerp(particle.opacity, baseParticleOpacity, 0.1); // Gradually fade if not in beam
                    }
                    particle.opacity = p.constrain(particle.opacity, 0, 255);

                    p.fill(255, 255, 230, particle.opacity); // Soft yellow particles
                    p.ellipse(particle.x, displayY, particle.size * particle.z, particle.size * particle.z);
                }
            }

            // Helper function to calculate the shortest distance from a point (px, py)
            // to a line segment (x1, y1) - (x2, y2)
            function distToLineSegment(p, px, py, x1, y1, x2, y2) {
                const l2 = p.dist(x1, y1, x2, y2) * p.dist(x1, y1, x2, y2);
                if (l2 === 0) return p.dist(px, py, x1, y1); // Segment is a point

                let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
                t = p.max(0, p.min(1, t)); // Clamp t to the range [0, 1]

                const closestX = x1 + t * (x2 - x1);
                const closestY = y1 + t * (y2 - y1);

                return p.dist(px, py, closestX, closestY);
            }


            /**
             * Recursively draws branches and leaves with a swaying motion.
             * @param {p5} p - The p5 instance.
             * @param {number} x1 - Starting x-coordinate.
             * @param {number} y1 - Starting y-coordinate.
             * @param {number} angle - Initial angle of the branch.
             * @param {number} len - Length of the branch.
             * @param {number} depth - Recursion depth (controls thickness and branching).
             */
            function drawBranch(p, x1, y1, angle, len, depth) {
                // --- Base Case: Stop recursing and draw leaves ---
                if (depth < baseDepth || len < baseLength) {
                    p.noStroke();
                    p.fill(20, 120, 50, 40); // Greenish colors with some transparency

                    const numLeaves = 3;
                    const leafRadius = 10;

                    for (let i = 0; i < numLeaves; i++) {
                        let offsetAngle = p.TWO_PI / numLeaves * i;
                        let offsetX = p.cos(offsetAngle) * leafRadius;
                        let offsetY = p.sin(offsetAngle) * leafRadius;

                        let leafSwayX = p.map(p.noise((x1 + offsetX) * 0.05, time), 0, 1, -1, 1);
                        let leafSwayY = p.map(p.noise((y1 + offsetY) * 0.05, time), 0, 1, -1, 1);

                        let leafSize = 25;
                        p.ellipse(x1 + offsetX + leafSwayX, y1 + offsetY + leafSwayY, leafSize, leafSize * 0.7);
                    }
                    return; // End this branch
                }

                // --- Calculate Sway ---
                let sway = p.map(p.noise(x1 * 0.001, y1 * 0.001, time), 0, 1, -0.1, 0.1);
                let currentAngle = angle + sway;

                // --- Calculate End Point ---
                let x2 = x1 + p.cos(currentAngle) * len;
                let y2 = y1 + p.sin(currentAngle) * len;

                // --- Draw the Branch ---
                p.strokeWeight(depth * 1.2);
                p.stroke(85, 56, 31);
                p.line(x1, y1, x2, y2);

                // --- Recursive Step: Draw new branches ---
                let newLen = len * 0.75;
                let newDepth = depth - 1;

                let noiseVal = p.noise(x2 * 0.1, y2 * 0.1, time);
                let angleVar = p.map(noiseVal, 0, 1, p.PI * 0.1, p.PI * 0.25);

                drawBranch(p, x2, y2, currentAngle - angleVar, newLen, newDepth);
                drawBranch(p, x2, y2, currentAngle + angleVar * 0.6, newLen * 0.9, newDepth);
                drawBranch(p, x2, y2, currentAngle, newLen * 0.7, newDepth - 1);
            }
        };

        // Get the container element and start the p5 sketch inside it.
        // This ensures the canvas is created within the specified div.
        const container = window.document.getElementById('canvas-container');
        new p5(sketch, container);

    </script>
</body>

</html>
