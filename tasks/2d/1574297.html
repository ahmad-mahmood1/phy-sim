<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            font-family: 'Roboto Mono', monospace;
        }

        #game-title {
            font-size: 28px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        #canvas-container {
            position: relative;
            /* This is crucial for the overlay positioning */
            border: 2px solid #444;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            width: 90vw;
            height: 70vh;
            max-width: 800px;
            max-height: 550px;
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            text-align: center;
        }

        .overlay-title {
            font-size: 48px;
            font-weight: bold;
            margin: 0;
        }

        .overlay-subtitle {
            font-size: 18px;
            margin-top: 10px;
        }

        #win-screen .overlay-title {
            color: #2ecc71;
        }

        #lose-screen .overlay-title {
            color: #e74c3c;
        }


        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        #controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        #instructions-container {
            margin-top: 15px;
            font-size: 14px;
            color: #555;
            text-align: center;
            max-width: 80%;
        }

        button {
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #555;
            cursor: pointer;
            background-color: #fff;
            box-shadow: 0 4px #999;
            transition: all 0.1s ease-in-out;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: 0 4px #888;
        }

        button:active:not(:disabled) {
            box-shadow: 0 2px #666;
            transform: translateY(2px);
        }

        #start-btn {
            background-color: #86e38b;
        }

        #reset-btn {
            background-color: #f0a3a3;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
            }
        }
    </script>

</head>

<body>
    <h1 id="game-title">Creeping Fig Plant</h1>
    <div id="canvas-container">
        <!-- The p5 canvas will be created here -->
        <div id="win-screen" class="game-overlay">
            <h2 class="overlay-title">You Win!</h2>
            <p class="overlay-subtitle">Press Reset to play again.</p>
        </div>
        <div id="lose-screen" class="game-overlay">
            <h2 class="overlay-title">Game Over!</h2>
            <p class="overlay-subtitle">Press Reset to play again.</p>
        </div>
    </div>
    <div id="controls">
        <button id="start-btn">Start Game</button>
        <button id="reset-btn">Reset Game</button>
    </div>
    <div id="instructions-container">
        <p>After starting the game, guide the vine with your mouse to reach the red planter. The vine only grows along
            the trellis slats!</p>
    </div>


    <script type="module">
        import p5 from 'p5';

        const sketch = (p) => {
            let figVine;
            let gardenTools = [];
            let brickWallTexture, mudTexture;
            let startJardiniere, endJardiniere;
            let vineStartPos, vineEndPos;
            let gameState = 'idle'; // 'idle', 'ready', 'playing', 'won', 'lost'

            let verticalSlatsX = [];
            let horizontalSlatsY = [];
            let trellisWidth;
            let pmouseX = 0, pmouseY = 0;

            const startBtn = document.getElementById('start-btn');
            const resetBtn = document.getElementById('reset-btn');
            const winScreen = document.getElementById('win-screen');
            const loseScreen = document.getElementById('lose-screen');
            const instructionsContainer = document.getElementById('instructions-container');

            let isInitialized = false;

            // --- UTILITY FUNCTIONS ---
            function findClosest(value, arr) {
                if (!arr || arr.length === 0) {
                    return 0;
                }
                return arr.reduce((prev, curr) => {
                    return (Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev);
                });
            }

            // --- GAME STATE MANAGEMENT ---
            function setGameState(newState) {
                gameState = newState;
                winScreen.style.display = (gameState === 'won') ? 'flex' : 'none';
                loseScreen.style.display = (gameState === 'lost') ? 'flex' : 'none';

                if (gameState === 'won' || gameState === 'lost') {
                    startBtn.disabled = true;
                }

                switch (gameState) {
                    case 'idle':
                        instructionsContainer.innerHTML = '<p>Press Start Game, then guide the vine with your mouse to reach the red planter.</p>';
                        break;
                    case 'ready':
                        instructionsContainer.innerHTML = '<p>Move your mouse to the green planter to begin growing!</p>';
                        startBtn.disabled = true;
                        break;
                    case 'playing':
                        instructionsContainer.innerHTML = '<p>Guide the vine along the trellis. Avoid the tools!</p>';
                        break;
                }
            }

            // --- LEVEL GENERATION ---
            function generateSolutionPath(startNode, endNode) {
                const gridW = verticalSlatsX.length;
                const gridH = horizontalSlatsY.length;

                if (gridW === 0 || gridH === 0) return new Set();

                const stack = [];
                const visited = Array(gridW).fill(null).map(() => Array(gridH).fill(false));

                stack.push(startNode);
                visited[startNode.c][startNode.r] = true;

                while (stack.length > 0) {
                    let current = stack[stack.length - 1];
                    if (current.c === endNode.c && current.r === endNode.r) break;

                    let { c, r } = current;
                    const directions = [ [1, 0], [0, 1], [-1, 0], [0, -1] ];
                    p.shuffle(directions, true);

                    let foundNeighbor = false;
                    for (const [dc, dr] of directions) {
                        let nc = c + dc;
                        let nr = r + dr;
                        if (nc >= 0 && nc < gridW && nr >= 0 && nr < gridH && !visited[nc][nr]) {
                            visited[nc][nr] = true;
                            stack.push({ c: nc, r: nr });
                            foundNeighbor = true;
                            break;
                        }
                    }
                    if (!foundNeighbor) stack.pop();
                }

                const solutionSegments = new Set();
                for (let i = 0; i < stack.length - 1; i++) {
                    const p1 = stack[i], p2 = stack[i + 1];
                    const segStr1 = `${p1.c},${p1.r}-${p2.c},${p2.r}`;
                    const segStr2 = `${p2.c},${p2.r}-${p1.c},${p1.r}`;
                    solutionSegments.add(segStr1 < segStr2 ? segStr1 : segStr2);
                }
                return solutionSegments;
            }

            function setupLevel() {
                gardenTools = [];
                const toolTypes = ['trowel', 'rake', 'shovel', 'pruningShears', 'gardenFork', 'wateringCan'];
                
                const startC = verticalSlatsX.indexOf(findClosest(vineStartPos.x, verticalSlatsX));
                const startR = horizontalSlatsY.indexOf(findClosest(vineStartPos.y, horizontalSlatsY));
                const endC = verticalSlatsX.indexOf(findClosest(vineEndPos.x, verticalSlatsX));
                const endR = horizontalSlatsY.indexOf(findClosest(vineEndPos.y, horizontalSlatsY));

                const solutionPath = generateSolutionPath({ c: startC, r: startR }, { c: endC, r: endR });

                const allSegments = [];
                 // Horizontal segments
                for (let r = 0; r < horizontalSlatsY.length; r++) {
                    for (let c = 0; c < verticalSlatsX.length - 1; c++) {
                        allSegments.push({ type: 'h', c1: c, r1: r, c2: c + 1, r2: r });
                    }
                }
                // Vertical segments
                for (let c = 0; c < verticalSlatsX.length; c++) {
                    for (let r = 0; r < horizontalSlatsY.length - 1; r++) {
                        allSegments.push({ type: 'v', c1: c, r1: r, c2: c, r2: r + 1 });
                    }
                }

                const lastColIndex = verticalSlatsX.length - 1;
                const lastRowIndex = horizontalSlatsY.length - 1;

                let potentialToolSegments = allSegments.filter(seg => {
                    // Exclude solution path
                    const segStr1 = `${seg.c1},${seg.r1}-${seg.c2},${seg.r2}`;
                    const segStr2 = `${seg.c2},${seg.r2}-${seg.c1},${seg.r1}`;
                    if (solutionPath.has(segStr1) || solutionPath.has(segStr2)) {
                        return false;
                    }

                    // Exclude the outermost border segments for tool placement
                    if (seg.type === 'h' && (seg.r1 === 0 || seg.r1 === lastRowIndex)) return false;
                    if (seg.type === 'v' && (seg.c1 === 0 || seg.c1 === lastColIndex)) return false;
                    
                    // Exclude the second-to-last border as well to give more space
                    if (seg.type === 'h' && (seg.r1 === 1 || seg.r1 === lastRowIndex -1)) return false;
                    if (seg.type === 'v' && (seg.c1 === 1 || seg.c1 === lastColIndex -1)) return false;

                    return true;
                });

                p.shuffle(potentialToolSegments, true);

                const numToolsToPlace = 8;
                const minToolDistance = 90; 

                for (let i = 0; i < numToolsToPlace && potentialToolSegments.length > 0; i++) {
                    const seg = potentialToolSegments.pop();
                    if (!seg) continue;

                    const toolX = (verticalSlatsX[seg.c1] + verticalSlatsX[seg.c2]) / 2;
                    const toolY = (horizontalSlatsY[seg.r1] + horizontalSlatsY[seg.r2]) / 2;
                    const newToolPos = p.createVector(toolX, toolY);

                    let collision = false;
                    for (const existingTool of gardenTools) {
                        if (newToolPos.dist(existingTool.pos) < minToolDistance) {
                            collision = true;
                            break;
                        }
                    }

                    if (!collision) {
                        gardenTools.push(new GardenTool(p.random(toolTypes), toolX, toolY, p.random(-p.PI / 16, p.PI / 16), seg.type));
                    } else {
                        i--; // Try again with another segment
                    }
                }

                figVine = new FigVine(vineStartPos.copy(), startC, startR);
            }

            function resetGame() {
                if (!isInitialized) return;
                setupLevel();
                setGameState('idle');
                startBtn.disabled = false;
            }

            // --- P5.JS SETUP & DRAW ---
            function initializeGame() {
                if (isInitialized || p.width === 0 || p.height === 0) {
                    return;
                }
                trellisWidth = p.width * 0.7;
                brickWallTexture = p.createGraphics(trellisWidth, p.height);
                generateBrickTexture(brickWallTexture);
                
                mudTexture = p.createGraphics(100, 100);
                generateMudTexture(mudTexture);

                const slatWidth = 10; // Made trellis thinner
                const numVerticalDivisions = 8;
                verticalSlatsX = [];
                for (let i = 0; i <= numVerticalDivisions; i++) {
                    const x = p.map(i, 0, numVerticalDivisions, -trellisWidth / 2, trellisWidth / 2);
                    verticalSlatsX.push(x);
                }
                const numHorizontalDivisions = 6;
                horizontalSlatsY = [];
                for (let i = 0; i <= numHorizontalDivisions; i++) {
                    const y = p.map(i, 0, numHorizontalDivisions, -p.height / 2 + slatWidth, p.height / 2 - slatWidth);
                    horizontalSlatsY.push(y);
                }
                
                const jardiniereCenterY = p.height / 2 - 25; // Moved planters to the edge
                const planterHeight = 50;
                startJardiniere = {
                    pos: p.createVector(verticalSlatsX[0], jardiniereCenterY),
                    color: p.color(100, 180, 100)
                };
                endJardiniere = {
                    pos: p.createVector(verticalSlatsX[verticalSlatsX.length - 1], jardiniereCenterY),
                    color: p.color(255, 0, 0) // Changed to red
                };

                // The vine starts from the center of the mud in the starting pot
                vineStartPos = p.createVector(startJardiniere.pos.x, startJardiniere.pos.y - planterHeight / 2 - 2);
                // The vine's goal is the center of the mud in the ending pot
                vineEndPos = p.createVector(endJardiniere.pos.x, endJardiniere.pos.y - planterHeight / 2 - 2);

                setupLevel();
                startBtn.addEventListener('click', () => {
                    if (gameState === 'idle') setGameState('ready');
                });
                resetBtn.addEventListener('click', resetGame);
                isInitialized = true;
            }

            p.setup = () => {
                const canvasContainer = document.getElementById('canvas-container');
                const canvas = p.createCanvas(canvasContainer.clientWidth, canvasContainer.clientHeight);
                canvas.parent(canvasContainer);
                p.rectMode(p.CENTER);
            };

            p.windowResized = () => {
                const canvasContainer = document.getElementById('canvas-container');
                p.resizeCanvas(canvasContainer.clientWidth, canvasContainer.clientHeight);
                isInitialized = false; 
                verticalSlatsX = [];
                horizontalSlatsY = [];
                initializeGame();
            };

            p.draw = () => {
                if (!isInitialized) {
                    initializeGame();
                    return;
                }

                p.translate(p.width / 2, p.height / 2);

                if (gameState === 'ready') {
                    const mousePos2D = p.createVector(p.mouseX - p.width / 2, p.mouseY - p.height / 2);
                    if (mousePos2D.dist(startJardiniere.pos) < 40) {
                        setGameState('playing');
                    }
                }
                
                // 1. Draw background elements
                p.background(135, 206, 235); // Sky blue
                drawGardenScenery();
                drawTrellisBackground();
                
                // 2. Update vine & tools logic
                const mouseTarget = p.createVector(p.mouseX - p.width / 2, p.mouseY - p.height / 2);
                figVine.update(gardenTools, mouseTarget);
                
                // 3. Draw elements in correct order for layering
                figVine.draw(false); // Draw the vine stem first (behind trellis)
                drawTrellis(); 
                drawHooks();
                
                for (const tool of gardenTools) {
                    tool.draw();
                }
                drawJardinieres(); // Draw planters on top of tools
                figVine.draw(true); // Draw the leaves on top of everything

                pmouseX = p.mouseX;
                pmouseY = p.mouseY;

            };

            // --- DRAWING FUNCTIONS ---
            function drawTrellisBackground() {
                p.image(brickWallTexture, -trellisWidth / 2, -p.height / 2, trellisWidth, p.height);
            }
            
            function drawGardenScenery() {
                p.push();
                p.noStroke();

                // Grass at the bottom
                p.fill(107, 142, 35); // Olive Drab
                p.rect(0, p.height / 2 - 20, p.width, 40);

                // Left and right side bushes
                const sideWidth = (p.width - trellisWidth) / 2;
                const leftSideX = -trellisWidth / 2 - sideWidth / 2;
                const rightSideX = trellisWidth / 2 + sideWidth / 2;
                
                p.fill(34, 139, 34); // Forest green for bushes
                // A few bushes on each side, moved down slightly
                p.ellipse(leftSideX, p.height / 2 - 30, 80, 80);
                p.ellipse(leftSideX + 30, p.height / 2 - 40, 60, 60);
                p.ellipse(rightSideX, p.height / 2 - 30, 90, 70);
                p.ellipse(rightSideX - 40, p.height / 2 - 35, 50, 50);

                p.pop();
            }

            function drawJardinieres() {
                [startJardiniere, endJardiniere].forEach(j => {
                    p.push();
                    p.translate(j.pos.x, j.pos.y);
                    p.stroke(87, 55, 26);
                    p.strokeWeight(2);
                    const tW = 70, bW = 50, h = 50;
                    
                    // Main body of the planter
                    p.fill(j.color);
                    p.quad(
                        -tW / 2, -h / 2,
                         tW / 2, -h / 2,
                         bW / 2,  h / 2,
                        -bW / 2,  h / 2
                    );
                    
                    // Mud is drawn before the rim so it appears inside
                    p.noStroke();
                    p.imageMode(p.CENTER);
                    p.image(mudTexture, 0, -h/2 + 2.5, tW - 10, 15);
                    p.imageMode(p.CORNER);

                    // Rim
                    p.stroke(87, 55, 26);
                    p.strokeWeight(2);
                    p.fill(p.red(j.color) * 0.8, p.green(j.color) * 0.8, p.blue(j.color) * 0.8);
                    p.rect(0, -h/2 - 5, tW + 5, 10);

                    p.pop();
                });
            }

            function generateBrickTexture(pg) {
                const bW = 60, bH = 25, m = 6;
                pg.background(180, 160, 150);
                pg.fill(210, 105, 30);
                pg.noStroke();
                for (let y = 0; y < pg.height; y += bH + m) {
                    for (let x = -bW; x < pg.width + bW; x += bW + m) {
                        let o = (p.floor(y / (bH + m)) % 2 === 1) ? -(bW + m) / 2 : 0;
                        pg.rect(x + o, y, bW, bH, 3);
                    }
                }
            }
            
            function generateMudTexture(pg) {
                // More realistic mud texture using Perlin noise
                const darkMud = p.color(60, 40, 30); // Dark, wet mud
                const lightMud = p.color(110, 80, 60); // Lighter, dry mud
                const detailColor = p.color(40, 25, 20, 180); // for small specks

                pg.background(92, 64, 51);
                pg.noStroke();
                // Create a base noise pattern by layering semi-transparent ellipses
                for (let i = 0; i < 5000; i++) {
                    const x = pg.random(pg.width);
                    const y = pg.random(pg.height);
                    // Get a noise value for the current position
                    const noiseVal = p.noise(x * 0.05, y * 0.05);
                    // Lerp the color based on the noise value
                    const mudColor = p.lerpColor(darkMud, lightMud, noiseVal);
                    mudColor.setAlpha(150); // Use alpha for soft blending
                    pg.fill(mudColor);
                    pg.ellipse(x, y, pg.random(10, 30));
                }

                // Add some extra detail like small clumps or pebbles
                for (let i = 0; i < 300; i++) {
                    const x = pg.random(pg.width);
                    const y = pg.random(pg.height);
                    const size = pg.random(1, 4);
                    pg.fill(detailColor);
                    pg.ellipse(x, y, size, size);
                }
            }
            
            function drawTrellis() {
                p.push();
                p.fill(139, 69, 19);
                p.stroke(87, 55, 26);
                p.strokeWeight(2);
                const sW = 10; // Made trellis thinner
                
                horizontalSlatsY.forEach(y => {
                    p.rect(0, y, trellisWidth, sW);
                });
                verticalSlatsX.forEach(x => {
                    p.rect(x, 0, sW, p.height);
                });
                p.pop();
            }

            function drawHooks() {
                for (const tool of gardenTools) {
                    p.push();
                    p.stroke(0); // Changed hook color to black
                    p.strokeWeight(3);
                    p.noFill();
                    
                    if (tool.hangingDirection === 'h') {
                        const hookY = findClosest(tool.pos.y, horizontalSlatsY);
                        p.arc(tool.pos.x, hookY + 4, 10, 10, p.PI, p.TWO_PI);
                        p.line(tool.pos.x, hookY - 5, tool.pos.x, hookY + 4);
                    } else { // 'v'
                        const hookX = findClosest(tool.pos.x, verticalSlatsX);
                        p.arc(hookX + 4, tool.pos.y, 10, 10, p.HALF_PI, p.PI + p.HALF_PI);
                        p.line(hookX - 5, tool.pos.y, hookX + 4, tool.pos.y);
                    }
                    p.pop();
                }
            }

            // --- CLASSES ---
            class FigVine {
                constructor(startPos, startGridC, startGridR) {
                    this.soilPoint = startPos.copy();
                    this.head = this.soilPoint.copy();
                    this.path = [this.soilPoint.copy()];
                    
                    this.isSprouting = true;
                    this.sproutTargetY = findClosest(this.soilPoint.y, horizontalSlatsY);
                    
                    this.velocity = p.createVector();
                    this.acceleration = p.createVector();
                    this.maxSpeed = 2.5;
                    this.maxForce = 0.3;
                    this.lastDirection = 'vertical';
                    this.visitedSegments = new Set();
                    this.currentGridNode = { c: startGridC, r: startGridR };
                }

                update(obstacles, target) {
                    if (gameState !== 'playing') return;

                    if (this.isSprouting) {
                        this.head.y -= 1.5; // Grow upwards at a constant speed
                        this.path.push(this.head.copy());
                        if (this.head.y <= this.sproutTargetY) {
                            this.head.y = this.sproutTargetY; // Snap to final position
                            this.isSprouting = false;
                            // Update the grid node now that we've landed on a slat
                            this.currentGridNode.r = horizontalSlatsY.indexOf(this.sproutTargetY);
                        }
                        return; // Don't do anything else while sprouting
                    }

                    const planter = endJardiniere;
                    const planterWidth = 70;
                    const planterHeight = 50;
                    const mudWidth = planterWidth - 5;
                    const mudHeight = 15;
                    const mudCenterY = planter.pos.y - planterHeight / 2 - 2;

                    const winZoneLeft = planter.pos.x - mudWidth / 2;
                    const winZoneRight = planter.pos.x + mudWidth / 2;
                    const winZoneTop = mudCenterY - mudHeight / 2;
                    const winZoneBottom = mudCenterY + mudHeight / 2;

                    if (this.head.x >= winZoneLeft && this.head.x <= winZoneRight && this.head.y >= winZoneTop && this.head.y <= winZoneBottom) {
                        setGameState('won');
                        return;
                    }

                    for (const obs of obstacles) {
                        if (obs.checkCollision(this.head)) {
                            setGameState('lost');
                            return;
                        }
                    }

                    const cVX_head = findClosest(this.head.x, verticalSlatsX);
                    const cVY_head = findClosest(this.head.y, horizontalSlatsY);
                    const atIntersection = p.abs(this.head.x - cVX_head) < 5 && p.abs(this.head.y - cVY_head) < 5;
                    const headC = verticalSlatsX.indexOf(cVX_head);
                    const headR = horizontalSlatsY.indexOf(cVY_head);

                    if (atIntersection && (headC !== this.currentGridNode.c || headR !== this.currentGridNode.r)) {
                        const prevNode = this.currentGridNode;
                        const currentNode = { c: headC, r: headR };
                        const segStr1 = `${prevNode.c},${prevNode.r}-${currentNode.c},${currentNode.r}`;
                        const segStr2 = `${currentNode.c},${currentNode.r}-${prevNode.c},${prevNode.r}`;
                        this.visitedSegments.add(segStr1 < segStr2 ? segStr1 : segStr2);
                        this.currentGridNode = currentNode;
                    }

                    let snappedTarget;
                    const closestVineSlatX = findClosest(this.head.x, verticalSlatsX);
                    const closestVineSlatY = findClosest(this.head.y, horizontalSlatsY);
                    const closestMouseSlatX = findClosest(target.x, verticalSlatsX);
                    const closestMouseSlatY = findClosest(target.y, horizontalSlatsY);

                    if (this.lastDirection === 'vertical') {
                        snappedTarget = p.createVector(closestVineSlatX, target.y);
                        if (atIntersection && closestMouseSlatX !== closestVineSlatX) {
                            const nextC = verticalSlatsX.indexOf(closestMouseSlatX);
                            const nextR = this.currentGridNode.r;
                            const segStr1 = `${this.currentGridNode.c},${this.currentGridNode.r}-${nextC},${nextR}`;
                            const segStr2 = `${nextC},${nextR}-${this.currentGridNode.c},${this.currentGridNode.r}`;
                            if (!this.visitedSegments.has(segStr1 < segStr2 ? segStr1 : segStr2)) {
                                this.lastDirection = 'horizontal';
                                snappedTarget = p.createVector(target.x, closestVineSlatY);
                            }
                        }
                    } else {
                        snappedTarget = p.createVector(target.x, closestVineSlatY);
                        if (atIntersection && closestMouseSlatY !== closestVineSlatY) {
                            const nextC = this.currentGridNode.c;
                            const nextR = horizontalSlatsY.indexOf(closestMouseSlatY);
                            const segStr1 = `${this.currentGridNode.c},${this.currentGridNode.r}-${nextC},${nextR}`;
                            const segStr2 = `${nextC},${nextR}-${this.currentGridNode.c},${this.currentGridNode.r}`;
                            if (!this.visitedSegments.has(segStr1 < segStr2 ? segStr1 : segStr2)) {
                                this.lastDirection = 'vertical';
                                snappedTarget = p.createVector(closestVineSlatX, target.y);
                            }
                        }
                    }
                    
                    // Constrain the target to the trellis boundaries
                    snappedTarget.x = p.constrain(snappedTarget.x, verticalSlatsX[0], verticalSlatsX[verticalSlatsX.length - 1]);
                    snappedTarget.y = p.constrain(snappedTarget.y, horizontalSlatsY[0], horizontalSlatsY[horizontalSlatsY.length - 1]);


                    let finalTarget = this.seek(snappedTarget);
                    this.applyForce(finalTarget);
                    this.velocity.add(this.acceleration);
                    this.velocity.limit(this.maxSpeed);
                    this.acceleration.mult(0);
                    
                    const distanceToTarget = this.head.dist(snappedTarget);

                    // Only add to the path and move if the vine hasn't reached the target.
                    // This allows the vine to "catch up" if the mouse stops moving.
                    if (distanceToTarget > 1) { // A small threshold to prevent jiggling
                        this.head.add(this.velocity);
                        if (this.velocity.mag() > 0.1) {
                            this.path.push(this.head.copy());
                        }
                    }
                }

                
                applyForce(force) {
                    this.acceleration.add(force);
                }
                seek(target) {
                    let desired = p5.Vector.sub(target, this.head);
                    desired.setMag(this.maxSpeed);
                    let steer = p5.Vector.sub(desired, this.velocity);
                    steer.limit(this.maxForce);
                    return steer;
                }

                draw(leavesOnly = false) {
                    const wrapThreshold = 10;
                    const wrapAmplitude = 12; 
                    const wrapFrequency = 0.1;

                    if (!leavesOnly) {
                        p.push();
                        p.stroke(40, 26, 13);
                        p.strokeWeight(8);
                        p.noFill();
                        p.beginShape();
                        for (let i = 0; i < this.path.length; i++) {
                            const v = this.path[i];
                            let finalX = v.x;
                            let finalY = v.y;
                            let wrapped = false;

                            // Check vertical poles
                            for (const x_pole of verticalSlatsX) {
                                if (p.abs(v.x - x_pole) < wrapThreshold) {
                                    const angle = v.y * wrapFrequency;
                                    finalX = x_pole + p.cos(angle) * wrapAmplitude;
                                    wrapped = true;
                                    break;
                                }
                            }

                            // Check horizontal poles
                            if (!wrapped) {
                                for (const y_pole of horizontalSlatsY) {
                                    if (p.abs(v.y - y_pole) < wrapThreshold) {
                                        const angle = v.x * wrapFrequency;
                                        finalY = y_pole + p.cos(angle) * wrapAmplitude;
                                        break;
                                    }
                                }
                            }
                            p.vertex(finalX, finalY);
                        }
                        p.endShape();
                        p.pop();
                    }

                    // Draw leaves with the same logic
                    if (leavesOnly) {
                        p.push();
                        p.fill(0, 100, 0);
                        p.noStroke();
                        for (let i = 10; i < this.path.length; i += 15) {
                            const point = this.path[i];
                            let finalX = point.x;
                            let finalY = point.y;
                            let wrapped = false;

                            // Check vertical poles for leaves
                            for (const x_pole of verticalSlatsX) {
                                if (p.abs(point.x - x_pole) < wrapThreshold) {
                                    const angle = point.y * wrapFrequency;
                                    finalX = x_pole + p.cos(angle) * wrapAmplitude;
                                    wrapped = true;
                                    break;
                                }
                            }

                            // Check horizontal poles for leaves
                            if (!wrapped) {
                                for (const y_pole of horizontalSlatsY) {
                                    if (p.abs(point.y - y_pole) < wrapThreshold) {
                                        const angle = point.x * wrapFrequency;
                                        finalY = y_pole + p.cos(angle) * wrapAmplitude;
                                        break;
                                    }
                                }
                            }
                            p.push();
                            p.translate(finalX, finalY);
                            p.rotate(p.noise(i * 0.1) * p.TWO_PI);
                            p.ellipse(0, -7, 15, 22);
                            p.pop();
                        }
                        p.pop();
                    }
                }
            }

            class GardenTool {
                constructor(type, x, y, rot, hangingDirection) {
                    this.type = type;
                    this.pos = p.createVector(x, y);
                    this.rotation = rot;
                    this.hangingDirection = hangingDirection;
                    this.handleColor = p.color(222, 184, 135);
                    this.metalColor = p.color(180, 180, 180);
                    this.redColor = p.color(255, 0, 0);
                    this.greenColor = p.color(0, 200, 0);
                    const scale = 0.6;
                    this.scale = scale;
                    switch (type) {
                        case 'trowel': this.width = 30 * scale; this.height = 110 * scale; break;
                        case 'rake': this.width = 60 * scale; this.height = 120 * scale; break;
                        case 'shovel': this.width = 50 * scale; this.height = 180 * scale; break;
                        case 'pruningShears': this.width = 50 * scale; this.height = 80 * scale; break;
                        case 'gardenFork': this.width = 50 * scale; this.height = 140 * scale; break;
                        case 'wateringCan': this.width = 100 * scale; this.height = 100 * scale; break;
                        default: this.width = 50 * scale; this.height = 100 * scale;
                    }
                }
                
                checkOBB(point, center, rotation, width, height) {
                    const translatedPoint = p5.Vector.sub(point, center);
                    const rotatedPoint = translatedPoint.copy().rotate(-rotation);
                    
                    const halfW = width / 2;
                    const halfH = height / 2;

                    return (rotatedPoint.x > -halfW && rotatedPoint.x < halfW &&
                            rotatedPoint.y > -halfH && rotatedPoint.y < halfH);
                }

                checkCollision(point) {
                    if (this.type === 'wateringCan') {
                        const canWidth = 80 * this.scale;
                        const canHeight = 70 * this.scale;
                        
                        // Body check
                        const bodyHit = this.checkOBB(point, this.pos, this.rotation, canWidth, canHeight);

                        // Spout check (approximated as a rotated rectangle)
                        const spoutOffset = p.createVector(-50 * this.scale, -20 * this.scale);
                        const spoutPos = this.pos.copy().add(spoutOffset.copy().rotate(this.rotation));
                        const spoutHit = this.checkOBB(point, spoutPos, this.rotation - p.PI / 6, 60 * this.scale, 15 * this.scale);

                        // Handle check (approximated as a rectangle)
                        const handleOffset = p.createVector(0, -60 * this.scale);
                        const handlePos = this.pos.copy().add(handleOffset.copy().rotate(this.rotation));
                        const handleHit = this.checkOBB(point, handlePos, this.rotation, 50 * this.scale, 20 * this.scale);

                        return bodyHit || spoutHit || handleHit;
                    } else if (this.type === 'rake') {
                        const scale = this.scale;
                        const handleCenterOffset = p.createVector(0, -30 * scale);
                        const handleCenter = this.pos.copy().add(handleCenterOffset.copy().rotate(this.rotation));
                        const handleHit = this.checkOBB(point, handleCenter, this.rotation, 12 * scale, 100 * scale);

                        const headCenterOffset = p.createVector(0, 35 * scale);
                        const headCenter = this.pos.copy().add(headCenterOffset.copy().rotate(this.rotation));
                        const headHit = this.checkOBB(point, headCenter, this.rotation, 60 * scale, 32 * scale);

                        return handleHit || headHit;
                    }
                    else {
                        // Standard OBB check for all other tools
                        return this.checkOBB(point, this.pos, this.rotation, this.width, this.height);
                    }
                }

                draw() {
                    p.push();
                    p.translate(this.pos.x, this.pos.y);
                    p.rotate(this.rotation);
                    p.scale(this.scale);
                    p.strokeWeight(2);
                    p.stroke(50);
                    const t = {
                        'trowel': this.drawTrowel, 'rake': this.drawRake, 'shovel': this.drawShovel,
                        'pruningShears': this.drawPruningShears, 'gardenFork': this.drawGardenFork,
                        'wateringCan': this.drawWateringCan,
                    };
                    t[this.type].call(this);
                    p.pop();
                }
                drawTrowel() {
                    p.fill(this.handleColor);
                    p.rect(0, -25, 12, 60);
                    p.fill(this.metalColor);
                    p.quad(-15, 5, 15, 5, 10, 45, -10, 45);
                }
                drawRake() {
                    p.fill(this.handleColor);
                    p.rect(0, -30, 12, 100);
                    p.fill(this.metalColor);
                    p.rect(0, 25, 60, 12);
                    for (let i = -2; i <= 2; i++) {
                        p.rect(i * 12, 40, 4, 20);
                    }
                }
                drawShovel() {
                    p.fill(this.handleColor);
                    p.noStroke();
                    p.rect(0, -40, 15, 120);

                    p.fill(this.metalColor);
                    p.stroke(140);
                    p.strokeWeight(2);
                    p.beginShape();
                    p.vertex(-25, 20);
                    p.vertex(25, 20);
                    p.vertex(15, 80);
                    p.quadraticVertex(0, 95, -15, 80);
                    p.endShape(p.CLOSE);

                    // Highlight to suggest curvature
                    p.noFill();
                    p.stroke(200);
                    p.strokeWeight(1.5);
                    p.line(0, 22, 0, 85);

                    p.stroke(50);
                }
                drawPruningShears() {
                    p.push();
                    if (this.hangingDirection === 'v') {
                        p.translate(15, 0); 
                    } else {
                        p.translate(0, 15); 
                    }
                    
                    p.fill(this.redColor);
                    p.rect(-10, 0, 10, 40);
                    p.rect(10, 0, 10, 40);
                    p.fill(this.metalColor);
                    p.push();
                    p.translate(-5, 25);
                    p.rotate(p.PI/8);
                    p.rect(0,0, 6, 30);
                    p.pop();
                    p.push();
                    p.translate(5, 25);
                    p.rotate(-p.PI/8);
                    p.rect(0,0, 6, 30);
                    p.pop();
                    p.pop();
                }
                drawGardenFork() {
                    p.fill(this.handleColor);
                    p.rect(0, -30, 15, 100);
                    p.fill(this.metalColor);
                    p.rect(0, 27.5, 50, 15);
                    for (let i = -1; i <= 1; i++) {
                        p.rect(i * 15, 50, 5, 40);
                    }
                }
                drawWateringCan() {
                    // Use metal color for the new can
                    const canWidth = 80;
                    const canHeight = 70;
                    const cornerRadius = 10;
                    p.fill(this.metalColor);
                    const darkerMetal = p.color(150);
                    p.stroke(darkerMetal);
                    p.strokeWeight(2);

                    // Main Body - Square type
                    p.rect(0, 0, canWidth, canHeight, cornerRadius);

                    // Shading on body
                    p.noStroke();
                    p.fill(darkerMetal);
                    p.rect(-canWidth / 4, 0, canWidth / 2, canHeight, cornerRadius);
                    p.stroke(darkerMetal);
                    p.strokeWeight(2);

                    // Top Rim
                    p.fill(this.metalColor);
                    p.rect(0, -canHeight / 2, canWidth, 10, 5);
                    
                    // Opening
                    p.noStroke();
                    p.fill(50); // Dark color for opening
                    p.rect(0, -canHeight / 2, canWidth - 10, 6, 3);

                    // Spout
                    p.noFill();
                    p.stroke(this.metalColor);
                    p.strokeWeight(10);
                    p.beginShape();
                    p.vertex(-canWidth / 2, 15);
                    p.bezierVertex(-70, -30, -80, -50, -60, -50);
                    p.endShape();

                    // Rose (sprinkler head)
                    p.fill(this.metalColor);
                    p.stroke(darkerMetal);
                    p.ellipse(-60, -50, 20, 20);

                    // Top Handle
                    p.noFill();
                    p.stroke(this.metalColor);
                    p.strokeWeight(8);
                    p.beginShape();
                    p.vertex(-25, -canHeight / 2 - 5);
                    p.bezierVertex(-30, -80, 30, -80, 25, -canHeight / 2 - 5);
                    p.endShape();
                    
                    // Reset stroke for other tools
                    p.stroke(50);
                }
            }
        };

        const container = document.getElementById('canvas-container');
        window.onload = function () {
            new p5(sketch, container);
        }

    </script>
</body>

</html>
