<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <title>Geometric Stars - Transitions Only</title>
    <style>
        body {
            margin: 0;
            background-color: #0d0d1a; /* Darker, slightly blue background */
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Roboto Mono', monospace;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
            }
        }
    </script>

</head>

<body>
    <div id="canvas-container">
    </div>
    <script type="module">
        import p5 from 'p5';

        const sketch = (p) => {
            // --- Simulation Controls ---
            const TRANSITION_SPEED = 0.03; // How fast arms split or merge.
            // --- End of Controls ---

            const stars = [];
            const targetStarCount = 200; // Adjusted for performance and aesthetics
            const placementAttempts = 500;

            class Star {
                constructor(x, y, outerRadius) {
                    this.x = x;
                    this.y = y;
                    this.outerRadius = outerRadius;
                    this.innerRadius = outerRadius / 2.0; // Made inner radius larger for more defined points
                    this.hue = p.random(50, 320); // Hues from blue to magenta
                    
                    // Star point logic
                    this.numPoints = p.floor(p.random(6, 8));
                    this.targetNumPoints = this.numPoints;

                    // State management for transitions
                    this.transitionState = 'stable';
                    this.transitionProgress = 0;
                    this.actionIndex = 0; 
                    this.timeUntilNextAction = p.random(10, 20);
                }
                
                // Helper function to get the base vertex position for a given index and point count
                getVertex(index, numPoints) {
                    // Alternate between outer and inner radius for the star points and valleys
                    const radius = (index % 2 === 0) ? this.outerRadius : this.innerRadius;
                    // Calculate the angle for the vertex
                    const angle = p.TWO_PI / (numPoints * 2) * index;
                    return { angle, radius };
                }

                // Update the star's state (handle transitions)
                update() {
                    // If the star is not currently splitting or merging
                    if (this.transitionState === 'stable') {
                        this.timeUntilNextAction--;
                        // When the timer runs out, initiate a new transition
                        if (this.timeUntilNextAction <= 0) {
                            this.initiateTransition();
                        }
                    }

                    // If the star is in a transition state
                    if (this.transitionState !== 'stable') {
                        this.transitionProgress += TRANSITION_SPEED;
                        // When the transition is complete
                        if (this.transitionProgress >= 1) {
                            this.numPoints = this.targetNumPoints; // Finalize the new point count
                            this.transitionState = 'stable';      // Reset state
                            this.transitionProgress = 0;
                            this.timeUntilNextAction = p.random(10, 20); // Reset timer for next action
                        }
                    }
                }

                // Decide whether to split an arm, merge arms, or do nothing
                initiateTransition() {
                    const canSplit = this.numPoints < 7; // Minimum points to split
                    const canMerge = this.numPoints >= 7;
                    let choice = 'none';

                    // Randomly choose an action based on constraints
                    if (canSplit && canMerge) choice = p.random(['splitting', 'merging']);
                    else if (canSplit) choice = 'splitting';
                    else if (canMerge) choice = 'merging';
                    
                    if (choice !== 'none') {
                        this.targetNumPoints = this.numPoints + 1 * (choice === 'splitting' ? 1 : -1);
                        this.actionIndex = p.floor(p.random(this.numPoints - 1));
                        this.transitionState = choice
                    }
                }
                
                // Main draw function, called every frame
                draw() {
                    this.update();

                    p.push();
                    p.translate(this.x, this.y);
                    
                    // Set drawing style for a glowing, geometric look
                    p.strokeWeight(1.5);
                    p.stroke(this.hue, 180, 255, 0.9); // Bright, slightly transparent stroke
                    p.fill(this.hue, 220, 255, 0.4);   // Dim, transparent fill
                    
                    p.beginShape();

                    // Call the correct drawing function based on the current state
                    if (this.transitionState === 'stable') this.drawStable();
                    else if (this.transitionState === 'splitting') this.drawSplitting();
                    else if (this.transitionState === 'merging') this.drawMerging();
                    
                    p.endShape(p.CLOSE);
                    p.pop();
                }

                // Draw the star in its normal, stable (non-moving) state
                drawStable() {
                    const totalVertices = this.numPoints * 2;
                    for (let i = 0; i < totalVertices; i++) {
                        const vertex = this.getVertex(i, this.numPoints);
                        
                        // --- Static Drawing Logic ---
                        // Draw the vertex without any noise-based morphing.
                        const sx = p.cos(vertex.angle) * vertex.radius;
                        const sy = p.sin(vertex.angle) * vertex.radius;
                        p.vertex(sx, sy);
                    }
                }
                
                // Draw the transition for an arm splitting into two
                drawSplitting() {
                    const prog = this.transitionProgress;
                    const startPoints = this.numPoints;
                    const endPoints = this.targetNumPoints;
                    const pointToSplitIdx = this.actionIndex * 2;

                    for (let i = 0; i < endPoints * 2; i++) {
                        const targetV = this.getVertex(i, endPoints);
                        let sourceV;
                        
                        if (i >= pointToSplitIdx && i <= pointToSplitIdx + 2) {
                            sourceV = this.getVertex(pointToSplitIdx, startPoints);
                        } else {
                            const sourceIdx = (i < pointToSplitIdx) ? i : i - 2;
                            sourceV = this.getVertex(sourceIdx, startPoints);
                        }
                        
                        const currentAngle = p.lerp(sourceV.angle, targetV.angle, prog);
                        const currentRadius = p.lerp(sourceV.radius, targetV.radius, prog);
                        
                        p.vertex(p.cos(currentAngle) * currentRadius, p.sin(currentAngle) * currentRadius);
                    }
                }

                // Draw the transition for two arms merging into one
                drawMerging() {
                    const prog = this.transitionProgress;
                    const startPoints = this.numPoints;
                    const endPoints = this.targetNumPoints;
                    const point1Idx = this.actionIndex * 2;
                    const valleyIdx = (point1Idx + 1) % (startPoints * 2);
                    const point2Idx = (point1Idx + 2) % (startPoints * 2);
                    const targetIdx = (this.actionIndex * 2) % (endPoints * 2);
                    const targetV = this.getVertex(targetIdx, endPoints);

                    for (let i = 0; i < startPoints * 2; i++) {
                        const sourceV = this.getVertex(i, startPoints);
                        let finalV;

                        if (i === point1Idx || i === valleyIdx || i === point2Idx) {
                            finalV = targetV;
                        } else {
                             let finalIdx = (this.actionIndex * 2 > i) ? i : i - 2;
                            finalV = this.getVertex(finalIdx, endPoints);
                        }

                        const currentAngle = p.lerp(sourceV.angle, finalV.angle, prog);
                        const currentRadius = p.lerp(sourceV.radius, finalV.radius, prog);

                        p.vertex(p.cos(currentAngle) * currentRadius, p.sin(currentAngle) * currentRadius);
                    }
                }
            }
            
            // Function to check if a new star overlaps with existing ones
            function checkOverlap(x, y, r, existingStars) {
                for (let star of existingStars) {
                    let d = p.dist(x, y, star.x, star.y);
                    if (d < r + star.outerRadius + 20) { // Increased padding
                        return true; 
                    }
                }
                return false; 
            }

            // Initial setup function
            p.setup = () => {
                const container = document.getElementById('canvas-container');
                p.createCanvas(container.offsetWidth, container.offsetHeight);
                p.colorMode(p.HSB, 360, 255, 255, 1); // Set HSB mode with alpha
                
                // Place stars randomly without letting them overlap
                let attempts = 0;
                while (stars.length < targetStarCount && attempts < targetStarCount * placementAttempts) {
                    let outerRadius = p.random(15, 55);
                    let x = p.random(outerRadius, p.width - outerRadius);
                    let y = p.random(outerRadius, p.height - outerRadius);

                    if (!checkOverlap(x, y, outerRadius, stars)) {
                        stars.push(new Star(x, y, outerRadius));
                    }
                    attempts++;
                }
                 if (stars.length < targetStarCount) {
                    console.warn(`Could only place ${stars.length}/${targetStarCount} stars. Try increasing canvas size or reducing star size/count.`);
                }
            };
            
            // Handle window resizing
            p.windowResized = () => {
                const container = document.getElementById('canvas-container');
                p.resizeCanvas(container.offsetWidth, container.offsetHeight);
                // Note: In a more complex sketch, you might want to re-place stars on resize.
            }

            // Main draw loop
            p.draw = () => {
                p.background(255, 10, 10, 1); // Dark blue-purple background
                for (const star of stars) {
                    star.draw();
                }
            };
        }

        const container = window.document.getElementById('canvas-container');
        new p5(sketch, container)
    </script>
</body>

</html>
