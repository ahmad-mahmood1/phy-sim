<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            /* Align items vertically */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* Ensure full viewport height */
            background-color: #f0f0f0;
            /* Light gray background */
            font-family: 'Roboto Mono', monospace;
            padding: 10px;
            /* Add some padding for smaller screens */
            box-sizing: border-box;
            position: relative;
        }

        #canvas-container {
            position: relative;
            border: 2px solid #333;
            /* Darker border */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            /* Softer shadow */
            margin-bottom: 15px;
            /* Space between canvas and controls */
            max-width: 100%;
            /* Ensure canvas container is responsive */
        }

        canvas {
            /* Style the canvas directly for p5.js */
            display: block;
            /* Removes extra space below canvas */
            max-width: 100%;
            height: auto;
            /* Maintain aspect ratio */
        }

        #radius-control-container {
            margin-bottom: 15px;
            padding: 10px 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }

        #radius-control-container label {
            font-size: 0.95em;
            margin-bottom: 8px;
            color: #333;
        }

        #radius-control-container input[type="range"] {
            width: 100%;
            max-width: 300px;
            cursor: pointer;
        }


        #instructions {
            font-size: 0.9em;
            color: #333;
            padding: 10px 15px;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 8px;
            /* More rounded corners */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            text-align: left;
            max-width: 600px;
            /* Match canvas width or adjust as needed */
            width: 90%;
            /* Responsive width */
            box-sizing: border-box;
        }

        #instructions ul {
            list-style-type: none;
            padding-left: 0;
            margin-top: 5px;
        }

        #instructions li {
            margin-bottom: 6px;
            line-height: 1.4;
        }

        #instructions strong {
            color: #0056b3;
            /* Slightly darker blue for better contrast */
            font-weight: 700;
        }

        .boundary-defining-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 1em;
            text-align: center;
            pointer-events: none;
            /* So it doesn't interfere with clicks */
        }

        #error {
            display: none;
            position: absolute;
            top: 10px;
            right: 0%;
            background-color: rgba(255, 247, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            color: black;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
            }
        }
    </script>

</head>

<body>
    <h2>
        Circle Packing Simulation
    </h2>
    <div id="canvas-container">
        <!-- p5.js canvas will be appended here -->
    </div>

    <div id="radius-control-container">
        <label for="radiusSlider">Circle Radius: <span id="radiusValueDisplay">20</span></label>
        <input type="range" id="radiusSlider" min="5" max="50" value="20">
    </div>

    <div id="instructions">
        <strong>Controls:</strong>
        <ul>
            <li><strong>Left Click:</strong> Add a circle (if space permits)</li>
            <li><strong>Right Click on Circle:</strong> Remove circle</li>
            <li><strong>Radius Slider:</strong> Adjust radius & re-initialize circles</li>
            <li><strong>'S':</strong> Settle/Organize circles</li>
            <li><strong>'R':</strong> Reset all circles (and add initial set)</li>
            <li><strong>'C':</strong> Toggle Circle / Rectangle Boundary</li>
            <li><strong>'B':</strong> Start/End defining custom polygon boundary (click to add points, then 'B' again to
                finish). Circles will be squeezed in.</li>
            <li><strong>'X':</strong> Reset to default Rectangle Boundary</li>
        </ul>
        <p style="font-style: italic; font-weight: 600;">Note: Changing boundary type or making a custom boundary will
            reset the circle
            count!</p>
    </div>
    <div id="error">

    </div>
    <script type="module">
        import p5 from 'p5';

        // Global variables for sketch
        let circles = [];
        let newCircleRadius = 20;
        const minCircleRadius = 10;
        const maxCircleRadius = 40;
        const boundaryPadding = 0.01;

        // Physics settings
        const iterations = 8;
        const damping = 0.98;
        const ADD_CIRCLE_SIMULATION_ITERATIONS = 200;

        let boundaryVertices = [];
        let boundaryType = 'rectangle';
        let definingBoundary = false;
        let tempBoundaryPoints = [];

        let shakeMagnitude = 2;
        let shaking = false;
        let shakeSteps = 0;
        const maxShakeSteps = 1;

        // Organizing/Settling mechanism variables
        let isOrganizing = false;
        let organizeSteps = 0;
        const maxOrganizeSteps = 5; // Increased steps for more settling time
        const organizeAttractionStrength = 0.002; // Tunable: How strongly circles are pulled to center
        const organizeDeadZoneRadius = newCircleRadius * 0.35;    // Tunable: Radius around center where attraction stops

        let radiusSlider;
        let radiusValueDisplay;

        let errorTimer = 1500 //ms
        let errorTriggeredAt = 0;

        let errorElement = document.getElementById('error');

        function setError(message) {
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }

        function clearError() {
            errorElement.textContent = '';
            errorElement.style.display = 'none';
        }


        const sketch = (p) => {
            let canvasWidth = 600;
            let canvasHeight = 400;
            let canvasElement;

            p.setup = () => {
                const canvas = p.createCanvas(canvasWidth, canvasHeight);
                canvas.parent('canvas-container');
                canvasElement = canvas.elt;

                radiusSlider = document.getElementById('radiusSlider');
                radiusValueDisplay = document.getElementById('radiusValueDisplay');

                if (radiusSlider && radiusValueDisplay) {
                    radiusSlider.min = minCircleRadius;
                    radiusSlider.max = maxCircleRadius;
                    radiusSlider.value = newCircleRadius;
                    radiusValueDisplay.innerHTML = newCircleRadius;

                    radiusSlider.addEventListener('input', () => {
                        let newRadius = parseInt(radiusSlider.value);
                        newCircleRadius = newRadius;
                        radiusValueDisplay.innerHTML = newRadius;
                        isOrganizing = true;
                        organizeSteps = 0;
                    });
                } else {
                    console.error("Radius slider or display element not found!");
                }

                resetBoundaryToRect();
                resetCircles();
                ensureCirclesInBounds();
                isOrganizing = true;
                organizeSteps = 0;

                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(12);
                p.textFont('Roboto Mono');
                console.log("Interactive Circle Packing Initialized. See on-screen controls.");

                if (canvasElement) {
                    canvasElement.oncontextmenu = (e) => e.preventDefault();
                }
            };

            function resetCircles() {
                circles = [];

            }

            function calculatePolygonCentroid(vertices) {
                if (!vertices || vertices.length === 0) return p.createVector(canvasWidth / 2, canvasHeight / 2);
                let centroid = p.createVector(0, 0);
                let signedArea = 0;
                let x0, y0, x1, y1, a;

                for (let i = 0; i < vertices.length; i++) {
                    x0 = vertices[i].x;
                    y0 = vertices[i].y;
                    x1 = vertices[(i + 1) % vertices.length].x;
                    y1 = vertices[(i + 1) % vertices.length].y;
                    a = x0 * y1 - x1 * y0;
                    signedArea += a;
                    centroid.x += (x0 + x1) * a;
                    centroid.y += (y0 + y1) * a;
                }

                if (signedArea === 0) {
                    if (vertices.length > 0) {
                        let sumX = 0, sumY = 0;
                        for (let v_item of vertices) { sumX += v_item.x; sumY += v_item.y; }
                        return p.createVector(sumX / vertices.length, sumY / vertices.length);
                    }
                    return p.createVector(canvasWidth / 2, canvasHeight / 2);
                }

                signedArea *= 0.5;
                centroid.x /= (6 * signedArea);
                centroid.y /= (6 * signedArea);

                if (isNaN(centroid.x) || isNaN(centroid.y) || !isFinite(centroid.x) || !isFinite(centroid.y)) {
                    console.warn("Centroid calculation resulted in NaN/Infinity. Falling back.");
                    return p.createVector(canvasWidth / 2, canvasHeight / 2);
                }
                return centroid;
            }


            class Circle {
                constructor(x, y, r) {
                    this.pos = p.createVector(x, y);
                    this.vel = p.createVector(p.random(-0.4, 0.4), p.random(-0.4, 0.4));
                    this.radius = r;
                    if (typeof p.color === 'function' && x.levels) {
                        this.color = x;
                    } else {
                        this.color = p.color(p.random(50, 200), p.random(80, 220), p.random(100, 255), 230);
                    }
                    this.id = Math.random().toString(36).substr(2, 9);
                }

                draw() {
                    if (isNaN(this.pos.x) || isNaN(this.pos.y) || !isFinite(this.pos.x) || !isFinite(this.pos.y)) {
                        return;
                    }
                    p.fill(this.color);
                    p.noStroke();
                    p.ellipse(this.pos.x, this.pos.y, this.radius * 2);
                }

                update() {
                    if (shaking) {
                        this.vel.add(p5.Vector.random2D().mult(shakeMagnitude * 0.2 * (1 - shakeSteps / maxShakeSteps)));
                    }
                    this.pos.add(this.vel);
                    this.vel.mult(damping);
                    if (this.vel.magSq() < 0.0001) {
                        this.vel.set(0, 0);
                    }
                }

                // New method to apply organizing forces
                applyOrganizingForces(targetPoint) {
                    let dirToTarget = p5.Vector.sub(targetPoint, this.pos);
                    let distToTarget = dirToTarget.mag();

                    // Only apply force if outside a "dead zone" and not too far (to prevent extreme pulls)
                    if (distToTarget > organizeDeadZoneRadius && distToTarget < p.max(canvasWidth, canvasHeight)) {
                        if (distToTarget > 0.01) { // Avoid normalizing zero vector
                            dirToTarget.normalize();
                        } else {
                            return;
                        }
                        // Force strength can be proportional to distance or a fixed amount
                        let forceMagnitude = (distToTarget - organizeDeadZoneRadius) * organizeAttractionStrength;
                        // Ensure forceMagnitude is not excessively large if distToTarget is huge
                        forceMagnitude = p.min(forceMagnitude, organizeAttractionStrength * 100); // Cap force

                        this.vel.add(dirToTarget.mult(forceMagnitude));
                    }
                }


                contains(px, py) {
                    return p.dist(px, py, this.pos.x, this.pos.y) < this.radius;
                }

                clone() {
                    let clonedCircle = new Circle(this.pos.x, this.pos.y, this.radius);
                    clonedCircle.vel = this.vel.copy();
                    clonedCircle.color = this.color;
                    clonedCircle.id = this.id;
                    return clonedCircle;
                }
            }

            p.draw = () => {
                p.background(245);

                // draw a circle that follows the mouse
                if (!definingBoundary) {
                    p.fill(255, 210, 0, 100);
                    p.noStroke();
                    p.ellipse(p.mouseX, p.mouseY, newCircleRadius * 2, newCircleRadius * 2);
                }

                drawBoundary();
                if (definingBoundary) {
                    drawTempBoundary();
                }

                if (errorTriggeredAt > 0 && p.millis() - errorTriggeredAt > errorTimer) {
                    clearError();
                    errorTriggeredAt = 0;
                }

                let currentPhysicsIterations = iterations;

                if (isOrganizing) {
                    currentPhysicsIterations = iterations * 3; // More iterations for settling
                    organizeSteps++;
                    if (organizeSteps > maxOrganizeSteps) {
                        isOrganizing = false;
                        organizeSteps = 0;
                        ensureCirclesInBounds();

                        console.log("Organizing finished.");
                    }

                    // Calculate boundary center for organizing forces
                    let boundaryCenter;
                    if (boundaryType === 'rectangle' || boundaryType === 'circle') {
                        boundaryCenter = p.createVector(canvasWidth / 2, canvasHeight / 2);
                    } else if (boundaryType === 'custom' && boundaryVertices.length > 2) {
                        boundaryCenter = calculatePolygonCentroid(boundaryVertices);
                    } else { // Fallback
                        boundaryCenter = p.createVector(canvasWidth / 2, canvasHeight / 2);
                    }

                    // Apply organizing forces once per frame, before physics iterations
                    if (boundaryCenter) {
                        circles.forEach(circle => {
                            circle.applyOrganizingForces(boundaryCenter);
                        });
                    }
                }


                for (let i = 0; i < currentPhysicsIterations; i++) {
                    circles.forEach(circle => {
                        circle.update();
                        applyBoundaryConstraints(circle);
                    });
                    for (let j = 0; j < circles.length; j++) {
                        for (let k = j + 1; k < circles.length; k++) {
                            resolveCollision(circles[j], circles[k]);
                        }
                    }
                }
                if (shaking) {
                    shakeSteps++;
                    if (shakeSteps > maxShakeSteps) {
                        shaking = false;
                        shakeSteps = 0;
                    }
                }

                circles.forEach(circle => circle.draw());

                p.fill(50);
                p.noStroke();
                p.textAlign(p.LEFT, p.TOP);
                p.textSize(11);
                p.text(`Global Radius: ${newCircleRadius}`, 10, 10);
                p.text(`Circles: ${circles.length}`, 10, 25);
                p.text(`Boundary: ${boundaryType}`, 10, 40);
                if (isOrganizing) {
                    p.text(`Organizing...`, 10, 55);
                }

                if (definingBoundary && canvasElement.parentElement) {
                    let existingMsg = canvasElement.parentElement.querySelector('.boundary-defining-text');
                    if (!existingMsg) {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'boundary-defining-text';
                        msgDiv.innerHTML = "DEFINING BOUNDARY<br>Click to add points. Press 'B' to finish.";
                        canvasElement.parentElement.appendChild(msgDiv);
                    }
                } else if (!definingBoundary && canvasElement.parentElement) {
                    let existingMsg = canvasElement.parentElement.querySelector('.boundary-defining-text');
                    if (existingMsg) existingMsg.remove();
                }
            };

            function addCircle(x, y, r) {
                clearError()

                let newCircle = new Circle(x, y, newCircleRadius);
                let canAdd = true;

                if (boundaryType === 'custom' && boundaryVertices.length > 2) {
                    if (!isPointInPolygon(p.createVector(x, y), boundaryVertices)) canAdd = false;
                } else if (boundaryType === 'circle') {
                    let distToCenter = p.dist(x, y, canvasWidth / 2, canvasHeight / 2);
                    if (distToCenter > p.min(canvasWidth, canvasHeight) / 2 - boundaryPadding - newCircleRadius) canAdd = false;
                } else if (boundaryType === 'rectangle') {
                    if (x - newCircleRadius < boundaryPadding || x + newCircleRadius > canvasWidth - boundaryPadding ||
                        y - newCircleRadius < boundaryPadding || y + newCircleRadius > canvasHeight - boundaryPadding) {
                        if (x < boundaryPadding || x > canvasWidth - boundaryPadding ||
                            y < boundaryPadding || y > canvasHeight - boundaryPadding) canAdd = false;
                    }
                }

                if (!canAdd) {
                    setError("Cannot add circle! Click position outside boundary or too close to edge.");
                    errorTriggeredAt = p.millis();
                    return false;
                }

                let clickPos = p.createVector(x, y);

                let tempCircles = circles.map(c => c.clone());
                let tempNewCircle = new Circle(x, y, r);
                tempNewCircle.vel.set(0, 0);
                tempCircles.push(tempNewCircle);
                let successfullyPlaced = false;

                for (let simStep = 0; simStep < ADD_CIRCLE_SIMULATION_ITERATIONS; simStep++) {
                    tempCircles.forEach(circle => {
                        circle.update();
                        applyBoundaryConstraints(circle); // Important: this needs to use the tempCircles context if it modifies others
                    });
                    for (let j = 0; j < tempCircles.length; j++) {
                        for (let k = j + 1; k < tempCircles.length; k++) {
                            resolveCollision(tempCircles[j], tempCircles[k]);
                        }
                    }
                }

                let isTempCircleOutOfBounds = checkOutOfBounds(tempNewCircle);
                let isTempCircleOverlappingSignificantly = false;

                for (const otherCircle of tempCircles) {
                    if (otherCircle.id === tempNewCircle.id) continue;
                    let distSq = p5.Vector.sub(tempNewCircle.pos, otherCircle.pos).magSq();
                    let combinedRadii = tempNewCircle.radius + otherCircle.radius;
                    // Stricter overlap check: if almost any overlap, consider it significant.
                    if (distSq < (combinedRadii * combinedRadii)) {
                        isTempCircleOverlappingSignificantly = true;
                        break;
                    }
                }

                if (!isTempCircleOutOfBounds && !isTempCircleOverlappingSignificantly) {
                    successfullyPlaced = true;
                }

                if (successfullyPlaced) {
                    circles.push(new Circle(x, y, r));
                    isOrganizing = true;
                    organizeSteps = 0;
                    return true;
                } else {
                    setError("Overlapping circle! Cannot place there.");
                    errorTriggeredAt = p.millis();
                    return false;
                }
            }

            function checkOutOfBounds(circle) {
                let oob = false;
                const r = circle.radius;
                const x = circle.pos.x;
                const y = circle.pos.y;

                if (boundaryType === 'rectangle') {
                    if (x - r < boundaryPadding - 0.1 || x + r > canvasWidth - boundaryPadding + 0.1 ||
                        y - r < boundaryPadding - 0.1 || y + r > canvasHeight - boundaryPadding + 0.1) {
                        oob = true;
                    }
                } else if (boundaryType === 'circle') {
                    let distToCenter = p.dist(x, y, canvasWidth / 2, canvasHeight / 2);
                    let boundaryCircleRadius = (p.min(canvasWidth, canvasHeight) / 2) - boundaryPadding;
                    if (distToCenter + r > boundaryCircleRadius + 0.1) {
                        oob = true;
                    }
                } else if (boundaryType === 'custom' && boundaryVertices.length > 2) {
                    if (!isPointInPolygon(circle.pos, boundaryVertices)) {
                        oob = true;
                    } else { // Check if any part of the circle body is outside, even if center is in
                        for (let i = 0; i < boundaryVertices.length; i++) {
                            let p1 = boundaryVertices[i];
                            let p2 = boundaryVertices[(i + 1) % boundaryVertices.length];
                            let closestPtOnSeg = closestPointOnSegment(circle.pos, p1, p2, false);
                            // If distance from center to closest point on segment is less than radius, it's penetrating
                            if (closestPtOnSeg && p5.Vector.dist(circle.pos, closestPtOnSeg) < r - 0.1) {
                                oob = true;
                                break;
                            }
                        }
                    }
                }
                return oob;
            }

            function resolveCollision(circleA, circleB) {
                let diff = p5.Vector.sub(circleB.pos, circleA.pos);
                let distSq = diff.magSq();
                let totalRadius = circleA.radius + circleB.radius;

                if (distSq < totalRadius * totalRadius && distSq > 0.0001) {
                    let dist = p.sqrt(distSq);
                    let overlap = totalRadius - dist;

                    diff.normalize();

                    let displacementA = diff.copy().mult(-overlap / 2);
                    let displacementB = diff.copy().mult(overlap / 2);

                    circleA.pos.add(displacementA);
                    circleB.pos.add(displacementB);

                } else if (distSq <= 0.0001 && circleA.id !== circleB.id) {
                    circleB.pos.add(p5.Vector.random2D().mult(0.1 * circleB.radius));
                }
            }

            function applyBoundaryConstraints(circle) {
                if (isNaN(circle.pos.x) || isNaN(circle.pos.y) || !isFinite(circle.pos.x) || !isFinite(circle.pos.y)) {
                    circle.pos.set(canvasWidth / 2, canvasHeight / 2);
                    circle.vel.set(0, 0);
                    return;
                }

                const r = circle.radius;
                const pos = circle.pos;
                const vel = circle.vel;


                if (boundaryType === 'rectangle') {
                    if (pos.x - r < boundaryPadding) {
                        pos.x = boundaryPadding + r;
                        vel.x *= -0.7;
                    }
                    if (pos.x + r > canvasWidth - boundaryPadding) {
                        pos.x = canvasWidth - boundaryPadding - r;
                        vel.x *= -0.7;
                    }
                    if (pos.y - r < boundaryPadding) {
                        pos.y = boundaryPadding + r;
                        vel.y *= -0.7;
                    }
                    if (pos.y + r > canvasHeight - boundaryPadding) {
                        pos.y = canvasHeight - boundaryPadding - r;
                        vel.y *= -0.7;
                    }
                } else if (boundaryType === 'circle') {
                    let center = p.createVector(canvasWidth / 2, canvasHeight / 2);
                    let boundaryRad = p.min(canvasWidth, canvasHeight) / 2 - boundaryPadding;
                    let distToCenter = p5.Vector.dist(pos, center);

                    if (distToCenter + r > boundaryRad) {
                        let overlap = (distToCenter + r) - boundaryRad;
                        let correctionDir = p5.Vector.sub(pos, center);
                        if (correctionDir.magSq() < 0.0001) {
                            correctionDir = p5.Vector.random2D();
                        } else {
                            correctionDir.normalize();
                        }
                        pos.sub(correctionDir.mult(overlap + 0.01));
                        if (vel.magSq() > 0) {
                            let normal = correctionDir.copy().mult(-1);
                            vel.reflect(normal);
                            vel.mult(0.7);
                        }
                    }
                } else if (boundaryType === 'custom' && boundaryVertices.length > 2) {
                    // If center is outside, first try to bring it to the closest point on polygon edge + radius inward
                    if (!isPointInPolygon(pos, boundaryVertices)) {
                        let closestData = closestPointOnPolygon(pos, boundaryVertices);
                        if (closestData && closestData.point) {
                            let closestBoundaryPoint = closestData.point;
                            let polygonCentroid = calculatePolygonCentroid(boundaryVertices);
                            let inwardDir = p5.Vector.sub(polygonCentroid, closestBoundaryPoint);
                            if (inwardDir.magSq() < 0.0001) inwardDir = p5.Vector.sub(polygonCentroid, pos); // if centroid and closest point are same
                            if (inwardDir.magSq() < 0.0001) inwardDir = p5.Vector.random2D(); // failsafe

                            inwardDir.normalize();
                            pos.set(p5.Vector.add(closestBoundaryPoint, inwardDir.mult(r + 0.1))); // Move inward by radius + epsilon
                            vel.mult(-0.1); // Dampen velocity significantly
                        }
                    }

                    // Then, iterate over segments to handle body penetration
                    for (let i = 0; i < boundaryVertices.length; i++) {
                        let p1 = boundaryVertices[i];
                        let p2 = boundaryVertices[(i + 1) % boundaryVertices.length];
                        let closestPtOnSeg = closestPointOnSegment(pos, p1, p2, false);
                        if (!closestPtOnSeg || isNaN(closestPtOnSeg.x) || isNaN(closestPtOnSeg.y)) continue;

                        let distToSegSq = p5.Vector.sub(pos, closestPtOnSeg).magSq();

                        // Check if circle body is penetrating the segment (dist to segment < radius)
                        if (distToSegSq < r * r - 0.001) { // using r*r to avoid sqrt, -0.001 for tolerance
                            let distToSeg = p.sqrt(distToSegSq);
                            let overlap = r - distToSeg;
                            if (overlap < 0) overlap = 0; // Should ideally not happen if condition is met

                            let pushVec = p5.Vector.sub(pos, closestPtOnSeg); // Vector from segment point to circle center

                            // If circle center is almost ON the segment, push perpendicular to segment
                            if (pushVec.magSq() < 0.0001) {
                                let segmentVec = p5.Vector.sub(p2, p1);
                                pushVec = p.createVector(-segmentVec.y, segmentVec.x); // Perpendicular
                                // Ensure pushVec points "outward" (away from polygon interior if circle is inside, or just away if outside)
                                let testPointTowardCentroid = p5.Vector.sub(calculatePolygonCentroid(boundaryVertices), pos).normalize().mult(0.1);
                                let currentPushDirTest = p5.Vector.add(pos, pushVec.copy().normalize().mult(0.1));
                                if (isPointInPolygon(currentPushDirTest, boundaryVertices)) { // if perpendicular push is inwards
                                    pushVec.mult(-1); // flip it
                                }

                            }
                            pushVec.normalize();
                            pos.add(pushVec.mult(overlap + 0.01)); // Push out by overlap amount + epsilon

                            let segmentNormal = pushVec.copy(); // The direction of push is the normal
                            vel.reflect(segmentNormal);
                            vel.mult(0.5);
                        }
                    }
                }

                if (isNaN(pos.x) || isNaN(pos.y) || !isFinite(pos.x) || !isFinite(pos.y)) {
                    pos.set(canvasWidth / 2, canvasHeight / 2);
                    vel.set(0, 0);
                }
            }

            function ensureCirclesInBounds() {
                const repositionPasses = 25; // More passes for complex scenarios
                const epsilon = 0.05; // Smaller epsilon for finer final adjustments

                for (let pass = 0; pass < repositionPasses; pass++) {
                    let adjustmentsThisPass = 0;
                    circles.forEach(circle => {
                        let oldPos = circle.pos.copy();
                        let targetPosCalculated = null;
                        let needsAdjustment = checkOutOfBounds(circle);

                        if (needsAdjustment) {
                            const r = circle.radius;
                            if (boundaryType === 'custom' && boundaryVertices.length > 2) {
                                let closestData = closestPointOnPolygon(circle.pos, boundaryVertices);
                                let polygonCentroid = calculatePolygonCentroid(boundaryVertices);
                                if (closestData && closestData.point) {
                                    let closestBoundaryPoint = closestData.point;
                                    let inwardDir = p5.Vector.sub(polygonCentroid, closestBoundaryPoint);
                                    if (inwardDir.magSq() < 0.0001) inwardDir = p5.Vector.sub(polygonCentroid, circle.pos);
                                    if (inwardDir.magSq() < 0.0001) inwardDir = p5.Vector.random2D();

                                    inwardDir.normalize();
                                    targetPosCalculated = p5.Vector.add(closestBoundaryPoint, inwardDir.mult(r + epsilon));

                                    let attempts = 0;
                                    // Create a temporary circle for checkOutOfBounds inside the loop
                                    let tempCheckCircle = new Circle(targetPosCalculated.x, targetPosCalculated.y, r);
                                    while (checkOutOfBounds(tempCheckCircle) && attempts < 15) { // Increased attempts
                                        let dirToCentroid = p5.Vector.sub(polygonCentroid, tempCheckCircle.pos);
                                        if (dirToCentroid.magSq() < 0.001) break;
                                        dirToCentroid.normalize().mult(r * 0.05 + epsilon); // Very small nudge
                                        tempCheckCircle.pos.add(dirToCentroid);
                                        attempts++;
                                    }
                                    targetPosCalculated = tempCheckCircle.pos; // Use the finally adjusted position

                                } else {
                                    targetPosCalculated = polygonCentroid.copy();
                                }
                            } else if (boundaryType === 'rectangle') {
                                targetPosCalculated = circle.pos.copy();
                                if (circle.pos.x - r < boundaryPadding) targetPosCalculated.x = boundaryPadding + r + epsilon;
                                else if (circle.pos.x + r > canvasWidth - boundaryPadding) targetPosCalculated.x = canvasWidth - boundaryPadding - r - epsilon;
                                if (circle.pos.y - r < boundaryPadding) targetPosCalculated.y = boundaryPadding + r + epsilon;
                                else if (circle.pos.y + r > canvasHeight - boundaryPadding) targetPosCalculated.y = canvasHeight - boundaryPadding - r - epsilon;
                            } else if (boundaryType === 'circle') {
                                let centerVec = p.createVector(canvasWidth / 2, canvasHeight / 2);
                                let boundaryActualRadius = p.min(canvasWidth, canvasHeight) / 2 - boundaryPadding;
                                let dirFromCenterToCircle = p5.Vector.sub(circle.pos, centerVec);
                                if (dirFromCenterToCircle.magSq() === 0) dirFromCenterToCircle = p5.Vector.random2D();
                                dirFromCenterToCircle.normalize();
                                let targetDist = boundaryActualRadius - r - epsilon;
                                if (targetDist < 0) targetDist = 0;
                                targetPosCalculated = p5.Vector.add(centerVec, dirFromCenterToCircle.mult(targetDist));
                            }

                            if (targetPosCalculated && (p5.Vector.dist(circle.pos, targetPosCalculated) > 0.001 || checkOutOfBounds(circle))) {
                                circle.pos.set(targetPosCalculated);
                                circle.vel.set(0, 0);
                                adjustmentsThisPass++;
                            }
                        }

                        if (isNaN(circle.pos.x) || isNaN(circle.pos.y) || !isFinite(circle.pos.x) || !isFinite(circle.pos.y)) {
                            circle.pos.set(oldPos);
                            circle.vel.set(0, 0);
                        }
                    });

                    if (adjustmentsThisPass === 0 && pass > 3) { // More initial passes before breaking
                        break;
                    }
                }
            }

            p.mousePressed = (event) => {
                if (event.target !== canvasElement) return;
                if (definingBoundary) {
                    if (p.mouseButton === p.LEFT) {
                        if (p.mouseX >= 0 && p.mouseX <= canvasWidth && p.mouseY >= 0 && p.mouseY <= canvasHeight) {
                            tempBoundaryPoints.push(p.createVector(p.mouseX, p.mouseY));
                        }
                    }
                } else {
                    if (p.mouseButton === p.LEFT) {
                        if (p.mouseX >= 0 && p.mouseX <= canvasWidth && p.mouseY >= 0 && p.mouseY <= canvasHeight) {
                            addCircle(p.mouseX, p.mouseY, newCircleRadius);
                        }
                    } else if (p.mouseButton === p.RIGHT) {
                        for (let i = circles.length - 1; i >= 0; i--) {
                            if (circles[i].contains(p.mouseX, p.mouseY)) {
                                circles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                return false;
            };

            p.keyPressed = () => {
                if (p.key === 'r' || p.key === 'R') {
                    resetBoundaryToRect();
                    resetCircles();
                    ensureCirclesInBounds();
                    isOrganizing = true;
                    organizeSteps = 0;
                } else if (p.key === 's' || p.key === 'S') {
                    isOrganizing = true;
                    organizeSteps = 0;
                    console.log("Organizing circles with gentle attraction...");

                    shaking = true
                    shakeSteps = 0
                }
                else if (p.key === 'c' || p.key === 'C') {
                    if (boundaryType === 'rectangle') {
                        boundaryType = 'circle';
                        boundaryVertices = [];
                    } else if (boundaryType === 'circle') {
                        boundaryType = 'rectangle';
                        resetBoundaryToRect();
                    } else {
                        boundaryType = 'rectangle';
                        resetBoundaryToRect();
                    }
                    resetCircles();
                    ensureCirclesInBounds();
                    isOrganizing = true;
                    organizeSteps = 0;
                } else if (p.key === 'b' || p.key === 'B') {
                    if (!definingBoundary) {
                        definingBoundary = true;
                        tempBoundaryPoints = [];
                        console.log("Started defining custom boundary. Click to add points. Press 'B' again to finish.");
                    } else {
                        definingBoundary = false;
                        if (tempBoundaryPoints.length > 2) {
                            boundaryVertices = [...tempBoundaryPoints];
                            boundaryType = 'custom';
                            console.log("Custom boundary defined with " + boundaryVertices.length + " vertices.");
                            tempBoundaryPoints = [];
                            resetCircles()
                            ensureCirclesInBounds();
                        } else {
                            console.log("Custom boundary definition cancelled: not enough points.");
                            tempBoundaryPoints = [];
                            if (boundaryType === 'custom' && (!boundaryVertices || boundaryVertices.length <= 2)) {
                                resetBoundaryToRect();
                                ensureCirclesInBounds();
                            }
                        }
                        isOrganizing = true;
                        organizeSteps = 0;
                    }
                } else if (p.key === 'x' || p.key === 'X') {
                    resetBoundaryToRect();
                    ensureCirclesInBounds();
                    isOrganizing = true;
                    organizeSteps = 0;
                }
            };

            function resetBoundaryToRect() {
                boundaryType = 'rectangle';
                boundaryVertices = [
                    p.createVector(boundaryPadding, boundaryPadding),
                    p.createVector(canvasWidth - boundaryPadding, boundaryPadding),
                    p.createVector(canvasWidth - boundaryPadding, canvasHeight - boundaryPadding),
                    p.createVector(boundaryPadding, canvasHeight - boundaryPadding)
                ];
                tempBoundaryPoints = [];
                definingBoundary = false;
            }

            function drawBoundary() {
                p.stroke(100);
                p.strokeWeight(2);
                p.noFill();

                if (boundaryType === 'rectangle') {
                    p.rect(boundaryPadding, boundaryPadding, canvasWidth - 2 * boundaryPadding, canvasHeight - 2 * boundaryPadding);
                } else if (boundaryType === 'circle') {
                    p.ellipse(canvasWidth / 2, canvasHeight / 2, p.min(canvasWidth, canvasHeight) - 2 * boundaryPadding);
                } else if (boundaryType === 'custom' && boundaryVertices.length > 2) {
                    p.beginShape();
                    boundaryVertices.forEach(v => {
                        if (v && !isNaN(v.x) && !isNaN(v.y)) {
                            p.vertex(v.x, v.y);
                        }
                    });
                    p.endShape(p.CLOSE);
                }
            }

            function drawTempBoundary() {
                p.stroke(0, 150, 255, 150);
                p.strokeWeight(2);
                p.noFill();
                p.beginShape();
                tempBoundaryPoints.forEach(pt => {
                    if (pt && !isNaN(pt.x) && !isNaN(pt.y)) {
                        p.vertex(pt.x, pt.y);
                    }
                });
                p.endShape();

                p.fill(0, 150, 255);
                p.noStroke();
                tempBoundaryPoints.forEach(pt => {
                    if (pt && !isNaN(pt.x) && !isNaN(pt.y)) {
                        p.ellipse(pt.x, pt.y, 8, 8);
                    }
                });
            }

            function isPointInPolygon(point, polygonVertices) {
                if (!polygonVertices || polygonVertices.length < 3 || !point || isNaN(point.x) || isNaN(point.y)) return false;
                let inside = false;
                for (let i = 0, j = polygonVertices.length - 1; i < polygonVertices.length; j = i++) {
                    let xi = polygonVertices[i].x, yi = polygonVertices[i].y;
                    let xj = polygonVertices[j].x, yj = polygonVertices[j].y;
                    if (isNaN(xi) || isNaN(yi) || isNaN(xj) || isNaN(yj)) continue;
                    let intersect = ((yi > point.y) !== (yj > point.y)) &&
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            function closestPointOnSegment(p_vec, a_vec, b_vec, onLine = false) {
                if (!p_vec || !a_vec || !b_vec ||
                    isNaN(p_vec.x) || isNaN(p_vec.y) || !isFinite(p_vec.x) || !isFinite(p_vec.y) ||
                    isNaN(a_vec.x) || isNaN(a_vec.y) || !isFinite(a_vec.x) || !isFinite(a_vec.y) ||
                    isNaN(b_vec.x) || isNaN(b_vec.y) || !isFinite(b_vec.x) || !isFinite(b_vec.y)
                ) {
                    return p.createVector(canvasWidth / 2, canvasHeight / 2);
                }

                let ap = p5.Vector.sub(p_vec, a_vec);
                let ab_segment_vector = p5.Vector.sub(b_vec, a_vec);
                let abMagSq = ab_segment_vector.magSq();

                if (abMagSq < 0.000001) { return a_vec.copy(); }
                let t = ap.dot(ab_segment_vector) / abMagSq;
                if (isNaN(t) || !isFinite(t)) {
                    return a_vec.copy();
                }
                if (!onLine) { t = p.constrain(t, 0, 1); }
                let projection = ab_segment_vector.copy().mult(t);
                return p5.Vector.add(a_vec, projection);
            }

            function closestPointOnPolygon(point, polygonVertices) {
                if (!polygonVertices || polygonVertices.length === 0 || !point || isNaN(point.x) || isNaN(point.y)) return null;
                if (polygonVertices.length === 1) {
                    if (isNaN(polygonVertices[0].x) || isNaN(polygonVertices[0].y)) return null;
                    return { point: polygonVertices[0].copy(), distSq: p5.Vector.sub(point, polygonVertices[0]).magSq() };
                }

                let closestPt = null;
                let minDistSq = Infinity;

                for (let i = 0; i < polygonVertices.length; i++) {
                    let p1 = polygonVertices[i];
                    let p2 = polygonVertices[(i + 1) % polygonVertices.length];
                    if (!p1 || !p2 || isNaN(p1.x) || isNaN(p1.y) || isNaN(p2.x) || isNaN(p2.y)) {
                        continue;
                    }
                    let currentClosestOnSeg = closestPointOnSegment(point, p1, p2, false);
                    if (!currentClosestOnSeg || isNaN(currentClosestOnSeg.x) || isNaN(currentClosestOnSeg.y)) {
                        continue;
                    }
                    let currentDistSq = p5.Vector.sub(point, currentClosestOnSeg).magSq();
                    if (isNaN(currentDistSq)) {
                        continue;
                    }
                    if (currentDistSq < minDistSq) {
                        minDistSq = currentDistSq;
                        closestPt = currentClosestOnSeg;
                    }
                }
                if (!closestPt) {
                    return null;
                }
                return { point: closestPt, distSq: minDistSq };
            }

        }; // End of sketch function

        const container = window.document.getElementById('canvas-container');
        new p5(sketch, container);

    </script>
</body>

</html>
