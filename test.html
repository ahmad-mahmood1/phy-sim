<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ping-Pong Ball Trajectory Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.dom.js"></script>
    <style>
        body {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin: 0;
            height: 100vh;
            background-color: #f0f0f0;
        }
        #control-panel {
            padding: 20px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        canvas {
            border: 1px solid #000;
        }
    </style>
</head>
<body>
    <div id="control-panel">
        <h3>Control Panel</h3>
        <label for="y-position">Initial Y Position:</label>
        <input type="range" id="y-position" min="0" max="400" value="200"><br>
        <label for="speed">Initial Speed:</label>
        <input type="range" id="speed" min="1" max="20" value="10"><br>
        <label for="angle">Initial Angle (degrees):</label>
        <input type="range" id="angle" min="0" max="90" value="45"><br>
        <button id="run-button">Run</button>
        <button id="reset-button">Reset</button>
        <h4>Ricochets:</h4>
        <div id="ricochet-data"></div>
    </div>
    <script>
        let sketch = (p) => {
            let ball;
            let ricochets = [];
            let isRunning = false;

            p.setup = () => {
                p.createCanvas(600, 400);
                ball = new Ball(p);
                p.drawPath();
                p.setupControls();
            };

            p.draw = () => {
                if (isRunning) {
                    ball.update();
                    ball.display();
                    if (ball.isOutOfBounds()) {
                      console.log("Ball out of bounds, stopping simulation.");
                        isRunning = false;
                    }
                }
            };

            p.setupControls = () => {
                const yPositionSlider = document.getElementById('y-position');
                const speedSlider = document.getElementById('speed');
                const angleSlider = document.getElementById('angle');
                const runButton = document.getElementById('run-button');
                const resetButton = document.getElementById('reset-button');
                const ricochetDataDiv = document.getElementById('ricochet-data');

                const updatePath = () => {
                    ball.initialY = parseFloat(yPositionSlider.value);
                    ball.initialSpeed = parseFloat(speedSlider.value);
                    ball.initialAngle = parseFloat(angleSlider.value);
                    ball.calculatePath();
                    p.drawPath();
                    ricochetDataDiv.innerHTML = ball.getRicochetData();
                };

                yPositionSlider.oninput = updatePath;
                speedSlider.oninput = updatePath;
                angleSlider.oninput = updatePath;

                runButton.onclick = () => {
                    ball.reset();
                    isRunning = true;
                };

                resetButton.onclick = () => {
                    ball.reset();
                    isRunning = false;
                    p.drawPath();
                };
            };

            p.drawPath = () => {
                p.clear();
                p.background(240);
                p.stroke(0);
                p.fill(255);
                p.rect(0, 0, p.width, p.height);
                ball.drawPath();
            };

            class Ball {
                constructor(p) {
                    this.p = p;
                    this.initialY = 100;
                    this.initialSpeed = 10;
                    this.initialAngle = 45;
                    this.reset();
                }

                reset() {
                    this.x = 50;
                    this.y = this.initialY;
                    this.speed = this.initialSpeed;
                    this.angle = this.initialAngle * (Math.PI / 180);
                    this.vx = this.speed * Math.cos(this.angle);
                    this.vy = -this.speed * Math.sin(this.angle);
                    this.ricochets = [];
                    this.calculatePath();
                }

                calculatePath() {
                    this.path = [];
                    let time = 0;
                    let dt = 0.1;
                    while (this.x >= 0 && this.x <= this.p.width && this.y >= 0 && this.y <= this.p.height) {
                        this.path.push({ x: this.x, y: this.y });
                        time += dt;
                        this.x = 50 + this.vx * time;
                        this.y = this.initialY + this.vy * time + 0.5 * 9.8 * time * time;

                        if (this.x <= 0 || this.x >= this.p.width) {
                            this.vx *= -1;
                            this.ricochets.push({ speed: this.speed, angle: this.angle * (180 / Math.PI) });
                        }
                        if (this.y <= 0 || this.y >= this.p.height) {
                            this.vy *= -1;
                            this.ricochets.push({ speed: this.speed, angle: this.angle * (180 / Math.PI) });
                        }
                    }
                }

                drawPath() {
                    this.p.stroke(150);
                    this.p.noFill();
                    this.p.beginShape();
                    for (let point of this.path) {
                        this.p.vertex(point.x, point.y);
                    }
                    this.p.endShape();
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += 9.8 * 0.1; // Gravity effect
                }

                display() {
                    this.p.fill(255, 0, 0);
                    this.p.ellipse(this.x, this.y, 20, 20);
                }

                isOutOfBounds() {
                    return this.x < 0 || this.x > this.p.width || this.y < 0 || this.y > this.p.height;
                }

                getRicochetData() {
                    return this.ricochets.map((r, index) => `Ricochet ${index + 1}: Speed = ${r.speed.toFixed(2)}, Angle = ${r.angle.toFixed(2)}Â°`).join('<br>');
                }
            }
        };

        new p5(sketch);
    </script>
</body>
</html>