<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jungle Swing</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #87CEEB;
        }
    </style>
    <!-- Import Map shim for browsers without native support -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <!-- Define all external dependencies in the import map -->
    <script type="importmap">
    {
        "imports": {
            "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
        }
    }
    </script>
</head>

<body>
    <script type="module">
        import p5 from 'p5';

        let sketch = function (p) {
            let monkey;
            let vines = [];
            let collectibles = [];
            let score = 0;
            let gameOver = false;
            let cameraOffsetX = 0;
            let currentVine = null;
            let lastVine = null;
            let cameraY = 0;
            let backgroundElements = [];

            p.setup = function () {
                p.createCanvas(p.windowWidth, p.windowHeight);
                p.angleMode(p.DEGREES);

                // Initialize background elements
                for (let i = 0; i < 50; i++) {
                    backgroundElements.push({
                        x: p.random(p.width),
                        y: p.random(-p.height, p.height),
                        size: p.random(5, 15),
                        speed: p.random(0.5, 1.5)
                    });
                }

                monkey = new Monkey(p.width / 2, p.height / 2);

                // Create initial vines
                vines.push(new Vine(p.width / 2, 100, "pendulum"));
                vines.push(new Vine(p.width / 2 + 200, 150, "spring"));
                vines.push(new Vine(p.width / 2 - 200, 120, "pendulum"));

                currentVine = vines[0];
                lastVine = vines[0];

                // Add some collectibles
                collectibles.push(new Collectible(p.width / 2 + 100, 80));
                collectibles.push(new Collectible(p.width / 2 - 150, 120));

                // Set initial camera position
                cameraOffsetX = -monkey.pos.x + p.width / 2;
            };

            p.draw = function () {
                p.background("#87CEEB");

                // Draw background elements (clouds)
                for (let cloud of backgroundElements) {
                    cloud.x += cloud.speed;
                    if (cloud.x > p.width) cloud.x = -cloud.size;
                    p.fill(255, 255, 255, 200);
                    p.noStroke();
                    p.ellipse(cloud.x, cloud.y, cloud.size, cloud.size * 0.6);
                }

                p.push();
                p.translate(cameraOffsetX, cameraY);

                // Draw ground
                p.fill(34, 139, 34);
                p.noStroke();
                p.rect(-p.width, p.height - 50, p.width * 3, 100);

                // Update and display vines
                for (let vine of vines) {
                    vine.update();
                    vine.display();
                }

                // Update and display collectibles
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    collectibles[i].update();
                    collectibles[i].display();

                    // Check for collection
                    if (monkey.grabCollectible(collectibles[i])) {
                        score += 50;
                        collectibles.splice(i, 1);
                    }
                }

                // Check for game over
                if (monkey.pos.y > p.height - 50 || monkey.checkCollision()) {
                    gameOver = true;
                }

                if (!gameOver) {
                    // Update and display monkey
                    monkey.update();
                    monkey.display();

                    // Check if monkey grabbed a new vine
                    for (let vine of vines) {
                        if (monkey.grabVine(vine)) {
                            if (vine !== lastVine) {
                                score += 10;
                                lastVine = vine;
                            }
                            currentVine = vine;
                            break;
                        }
                    }

                    // Add new vines and collectibles as player progresses
                    if (monkey.pos.x > p.width * 0.6 && vines.length < 8) {
                        vines.push(new Vine(p.random(p.width * 0.7, p.width * 0.9), p.random(80, 150), p.random(["pendulum", "spring"])));
                        if (p.random() > 0.7) {
                            collectibles.push(new Collectible(p.random(p.width * 0.7, p.width * 0.9), p.random(50, 120)));
                        }
                    }

                    // Update camera position
                    cameraOffsetX = p.lerp(cameraOffsetX, -monkey.pos.x + p.width / 2, 0.1);
                    cameraY = p.lerp(cameraY, -monkey.pos.y + p.height / 2, 0.1);
                } else {
                    // Game Over screen
                    p.fill(0, 0, 0, 150);
                    p.rect(-p.width, -p.height, p.width * 3, p.height * 3);

                    p.fill(255);
                    p.textSize(48);
                    p.textAlign(p.CENTER);
                    p.text("Game Over", p.width / 2 - cameraOffsetX, p.height / 2 - cameraY);

                    p.textSize(24);
                    p.text("Final Score: " + score, p.width / 2 - cameraOffsetX, p.height / 2 + 30 - cameraY);
                    p.text("Click to Restart", p.width / 2 - cameraOffsetX, p.height / 2 + 60 - cameraY);
                }

                p.pop();

                // Display UI
                p.fill(255);
                p.textSize(24);
                p.textAlign(p.LEFT);
                p.text("Score: " + score, 20, 40);
            };

            p.mousePressed = function () {
                if (gameOver) {
                    // Restart game
                    score = 0;
                    gameOver = false;
                    monkey = new Monkey(p.width / 2, p.height / 2);
                    vines = [];
                    collectibles = [];
                    backgroundElements = [];

                    // Reset background elements
                    for (let i = 0; i < 50; i++) {
                        backgroundElements.push({
                            x: p.random(p.width),
                            y: p.random(-p.height, p.height),
                            size: p.random(5, 15),
                            speed: p.random(0.5, 1.5)
                        });
                    }

                    // Create initial vines
                    vines.push(new Vine(p.width / 2, 100, "pendulum"));
                    vines.push(new Vine(p.width / 2 + 200, 150, "spring"));
                    vines.push(new Vine(p.width / 2 - 200, 120, "pendulum"));

                    currentVine = vines[0];
                    lastVine = vines[0];

                    // Add some collectibles
                    collectibles.push(new Collectible(p.width / 2 + 100, 80));
                    collectibles.push(new Collectible(p.width / 2 - 150, 120));
                } else if (currentVine) {
                    // Release from current vine
                    currentVine.release();
                    currentVine = null;
                }
            };

            p.keyPressed = function () {
                if (p.key === ' ') {
                    monkey.boost();
                }
            };

            class Monkey {
                constructor(x, y) {
                    this.pos = p.createVector(x, y);
                    this.vel = p.createVector(0, 0);
                    this.acc = p.createVector(0, 0.5); // Gravity
                    this.radius = 20;
                    this.attachedVine = null;
                    this.swingAngle = 0;
                    this.swingAngularVelocity = 0;
                    this.boosting = false;
                    this.boostTimer = 0;
                }

                update() {
                    if (this.attachedVine) {
                        // Update swinging physics
                        let gravityTorque = -0.2 * p.sin(this.swingAngle);
                        this.swingAngularVelocity += gravityTorque;
                        this.swingAngle += this.swingAngularVelocity;

                        // Dampen swing
                        this.swingAngularVelocity *= 0.99;

                        // Calculate position based on swing
                        this.pos.x = this.attachedVine.pos.x + p.cos(this.swingAngle) * this.attachedVine.length;
                        this.pos.y = this.attachedVine.pos.y + p.sin(this.swingAngle) * this.attachedVine.length;

                        this.vel.x = p.cos(this.swingAngle + 90) * this.swingAngularVelocity * this.attachedVine.length;
                        this.vel.y = p.sin(this.swingAngle + 90) * this.swingAngularVelocity * this.attachedVine.length;
                    } else {
                        // Apply physics when not attached
                        this.vel.add(this.acc);
                        this.pos.add(this.vel);

                        // Apply boost if active
                        if (this.boosting) {
                            this.vel.mult(0.8); // Reduce velocity while boosting
                            this.boostTimer++;
                            if (this.boostTimer > 10) {
                                this.boosting = false;
                                this.boostTimer = 0;
                            }
                        }
                    }
                }

                display() {
                    p.push();
                    p.translate(this.pos.x, this.pos.y);

                    if (this.attachedVine) {
                        p.rotate(this.swingAngle + 90);
                    }

                    // Draw body
                    p.fill(165, 42, 42);
                    p.ellipse(0, 0, this.radius * 2);

                    // Draw face
                    p.fill(255);
                    p.ellipse(0, -this.radius, this.radius, this.radius * 0.8);

                    // Draw eyes
                    p.fill(0);
                    p.ellipse(-this.radius * 0.3, -this.radius, this.radius * 0.2);
                    p.ellipse(this.radius * 0.3, -this.radius, this.radius * 0.2);

                    // Draw arms
                    p.stroke(165, 42, 42);
                    p.strokeWeight(3);
                    p.line(-this.radius, 0, -this.radius * 1.5, -this.radius);
                    p.line(this.radius, 0, this.radius * 1.5, -this.radius);

                    p.pop();
                }

                grabVine(vine) {
                    if (p.dist(this.pos.x, this.pos.y, vine.pos.x, vine.pos.y) < vine.radius + this.radius) {
                        this.attachedVine = vine;
                        vine.attach(this);
                        return true;
                    }
                    return false;
                }

                grabCollectible(collectible) {
                    if (p.dist(this.pos.x, this.pos.y, collectible.pos.x, collectible.pos.y) < collectible.radius + this.radius) {
                        return true;
                    }
                    return false;
                }

                boost() {
                    if (!this.boosting && !this.attachedVine) {
                        this.boosting = true;
                        this.vel.y -= 10; // Apply upward force
                    }
                }

                checkCollision() {
                    // Check for collision with falling objects (coconuts)
                    for (let vine of vines) {
                        if (vine.hazard && p.dist(this.pos.x, this.pos.y, vine.pos.x, vine.pos.y + vine.length) < vine.radius + this.radius) {
                            return true;
                        }
                    }
                    return false;
                }
            }

            class Vine {
                constructor(x, y, type) {
                    this.pos = p.createVector(x, y);
                    this.length = p.random(150, 250);
                    this.radius = 10;
                    this.type = type;
                    this.attachedMonkey = null;
                    this.anchorPoint = p.createVector(x, y);
                    this.restLength = this.length;
                    this.stiffness = 0.1;
                    this.damping = 0.95;
                    this.angle = 0;
                    this.angularVelocity = 0;
                    this.hazard = p.random() > 0.8; // Some vines have falling hazards
                }

                update() {
                    if (this.attachedMonkey) {
                        if (this.type === "pendulum") {
                            // Pendulum physics
                            this.angle = p.atan2(this.attachedMonkey.pos.y - this.anchorPoint.y, this.attachedMonkey.pos.x - this.anchorPoint.x);
                            let gravityTorque = -0.2 * p.sin(this.angle);
                            this.angularVelocity += gravityTorque;
                            this.angularVelocity *= this.damping;
                            this.angle += this.angularVelocity;
                        } else if (this.type === "spring") {
                            // Spring physics
                            let dx = this.attachedMonkey.pos.x - this.anchorPoint.x;
                            let dy = this.attachedMonkey.pos.y - this.anchorPoint.y;
                            let distance = p.sqrt(dx * dx + dy * dy);

                            // Calculate spring force
                            let force = (distance - this.restLength) * this.stiffness;
                            let forceX = force * dx / distance;
                            let forceY = force * dy / distance;

                            // Apply force to monkey
                            this.attachedMonkey.vel.x += forceX;
                            this.attachedMonkey.vel.y += forceY;
                        }
                    } else if (this.type === "pendulum") {
                        // Update pendulum motion when not attached
                        let gravityTorque = -0.2 * p.sin(this.angle);
                        this.angularVelocity += gravityTorque;
                        this.angularVelocity *= this.damping;
                        this.angle += this.angularVelocity;
                    }

                    // Update hazard position
                    if (this.hazard) {
                        this.pos.y += 2;
                        if (this.pos.y > p.height) {
                            this.pos.y = this.anchorPoint.y;
                        }
                    }
                }

                display() {
                    p.push();
                    p.translate(this.anchorPoint.x, this.anchorPoint.y);

                    if (this.type === "pendulum") {
                        p.rotate(this.angle);
                    }

                    // Draw vine
                    p.stroke(139, 69, 19);
                    p.strokeWeight(4);
                    p.line(0, 0, 0, this.length);

                    // Draw attachment point
                    p.fill(160, 82, 45);
                    p.noStroke();
                    p.ellipse(0, this.length, this.radius * 2);

                    p.pop();

                    // Draw hazard
                    if (this.hazard) {
                        p.fill(255, 140, 0);
                        p.noStroke();
                        p.ellipse(this.pos.x, this.pos.y + this.length, 20);
                    }
                }

                attach(monkey) {
                    this.attachedMonkey = monkey;
                }

                release() {
                    if (this.attachedMonkey) {
                        this.attachedMonkey.attachedVine = null;
                        this.attachedMonkey = null;
                    }
                }
            }

            class Collectible {
                constructor(x, y) {
                    this.pos = p.createVector(x, y);
                    this.radius = 15;
                    this.bobOffset = p.random(100);
                    this.bobSpeed = p.random(0.02, 0.05);
                }

                update() {
                    // Bob up and down
                    this.pos.y = this.pos.y + p.sin(p.frameCount * this.bobSpeed) * 0.5;
                }

                display() {
                    // Draw banana
                    p.fill(255, 215, 0);
                    p.noStroke();
                    p.ellipse(this.pos.x, this.pos.y, this.radius * 2, this.radius * 1.5);

                    // Draw banana curve
                    p.stroke(255, 215, 0);
                    p.strokeWeight(2);
                    p.noFill();
                    p.beginShape();
                    p.curveVertex(this.pos.x - this.radius, this.pos.y);
                    p.curveVertex(this.pos.x - this.radius, this.pos.y);
                    p.curveVertex(this.pos.x, this.pos.y - this.radius * 0.8);
                    p.curveVertex(this.pos.x + this.radius, this.pos.y);
                    p.curveVertex(this.pos.x + this.radius, this.pos.y);
                    p.endShape();
                }
            }

            p.windowResized = function () {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
            };
        };

        new p5(sketch);
    </script>
</body>

</html>