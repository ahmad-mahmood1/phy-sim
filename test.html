<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4-to-1 MUX Heat Simulation</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #main-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 20px;
    }

    #info-card,
    #controls {
      margin-top: 20px;
      font-family: Arial, sans-serif;
    }

    #controls {
      font-size: 1.2em;
      font-weight: bold;
    }
  </style>
  <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
            }
        }
    </script>
</head>

<body>
  <div id="main-container">
    <div id="info-card">
      This simulation demonstrates heat distribution on a 4-to-1 multiplexer circuit board. The active input channel
      cycles every 2 seconds.
    </div>
    <div id="simulation-container"></div>
    <div id="controls">Active Channel: <span id="channel-number">1</span></div>
  </div>
  <script type="module">
    import p5 from 'p5';

    const sketch = (p) => {
      let gridSize = 100;
      let grid;
      let activeChannel = 0;
      let lastSwitchTime = 0;
      let coolingRate = 0.01;
      let diffusionRate = 0.1;

      // Circuit coordinates
      let chipCenter = { x: gridSize * 0.5, y: gridSize * 0.6 };
      let inputPads = [
        { x: gridSize * 0.2, y: gridSize * 0.2 }, // Input 0
        { x: gridSize * 0.4, y: gridSize * 0.2 }, // Input 1
        { x: gridSize * 0.6, y: gridSize * 0.2 }, // Input 2
        { x: gridSize * 0.8, y: gridSize * 0.2 }  // Input 3
      ];
      let outputPad = { x: gridSize * 0.5, y: gridSize * 0.9 };

      // Trace coordinates
      let muxCenter = { x: gridSize * 0.5, y: gridSize * 0.6 };
      let muxInputs = [
        { x: gridSize * 0.35, y: gridSize * 0.55 }, // Input 0
        { x: gridSize * 0.45, y: gridSize * 0.55 }, // Input 1
        { x: gridSize * 0.55, y: gridSize * 0.55 }, // Input 2
        { x: gridSize * 0.65, y: gridSize * 0.55 }  // Input 3
      ];
      let muxOutput = { x: gridSize * 0.5, y: gridSize * 0.75 };
      let outputJunction = { x: gridSize * 0.5, y: gridSize * 0.8 };

      p.setup = () => {
        let canvas = p.createCanvas(gridSize, gridSize);
        canvas.parent('simulation-container');
        p.frameRate(30);
        initGrid();
      };

      p.draw = () => {
        updateGrid();
        render();
      };

      function initGrid() {
        grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
      }

      function updateGrid() {
        if (p.millis() - lastSwitchTime > 2000) {
          activeChannel = (activeChannel + 1) % 4;
          lastSwitchTime = p.millis();
          document.getElementById('channel-number').textContent = activeChannel + 1;
        }

        // Diffusion and cooling
        for (let x = 1; x < gridSize - 1; x++) {
          for (let y = 1; y < gridSize - 1; y++) {
            let temp = grid[x][y];
            let neighbors = [
              grid[x - 1][y], grid[x + 1][y],
              grid[x][y - 1], grid[x][y + 1]
            ].reduce((a, b) => a + b, 0) / 4;
            grid[x][y] = temp * (1 - diffusionRate) + neighbors * diffusionRate;
            grid[x][y] *= (1 - coolingRate);
          }
        }

        // Inject heat into active channel
        let activeTrace = getTracePath(activeChannel);
        for (let point of activeTrace) {
          grid[point.x][point.y] = 255;
        }
      }

      function render() {
        p.background(220);

        // Render static circuit components
        drawTraces();
        drawPads();
        drawChip();

        // Render heat map
        p.noStroke();
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            let temp = grid[x][y];
            if (temp > 0) {
              let c = p.color(255, 0, 0, temp * 0.8); // Limit max alpha for better visibility
              p.fill(c);
              p.rect(x, y, 1, 1);
            }
          }
        }
      }

      function drawTraces() {
        p.stroke(139, 69, 19); // Brown color for traces
        p.strokeWeight(2);
        for (let i = 0; i < 4; i++) {
          let start = inputPads[i];
          let end = muxInputs[i];
          p.line(start.x, start.y, end.x, end.y);
        }
        for (let i = 0; i < 4; i++) {
          let start = muxInputs[i];
          let end = muxCenter;
          p.line(start.x, start.y, end.x, end.y);
        }
        p.line(muxCenter.x, muxCenter.y, muxOutput.x, muxOutput.y);
        p.line(muxOutput.x, muxOutput.y, outputJunction.x, outputJunction.y);
        p.line(outputJunction.x, outputJunction.y, outputPad.x, outputPad.y);
      }

      function drawPads() {
        p.fill(180); // Light gray for pads
        p.noStroke();
        let padSize = 5;
        for (let pad of inputPads.concat([outputPad])) {
          p.rect(pad.x - padSize / 2, pad.y - padSize / 2, padSize, padSize);
        }
      }

      function drawChip() {
        p.fill(100); // Dark gray for chip
        p.noStroke();
        let chipSize = 15;
        p.rect(chipCenter.x - chipSize / 2, chipCenter.y - chipSize / 2, chipSize, chipSize);
      }

      function getTracePath(channel) {
        let path = [];
        let start = inputPads[channel];
        let end = muxInputs[channel];

        // Input trace
        for (let x = p.floor(p.min(start.x, end.x)); x <= p.floor(p.max(start.x, end.x)); x++) {
          path.push({ x, y: p.floor(start.y) });
        }
        // Vertical segment
        for (let y = p.floor(p.min(start.y, end.y)); y <= p.floor(p.max(start.y, end.y)); y++) {
          path.push({ x: p.floor(end.x), y });
        }

        // Internal MUX path
        for (let i = 0; i < 4; i++) {
          let input = muxInputs[i];
          for (let y = p.floor(p.min(input.y, muxCenter.y)); y <= p.floor(p.max(input.y, muxCenter.y)); y++) {
            path.push({ x: p.floor(input.x), y });
          }
        }
        for (let x = p.floor(p.min(muxCenter.x, muxOutput.x)); x <= p.floor(p.max(muxCenter.x, muxOutput.x)); x++) {
          path.push({ x, y: p.floor(muxCenter.y) });
        }
        for (let y = p.floor(p.min(muxOutput.y, outputJunction.y)); y <= p.floor(p.max(muxOutput.y, outputJunction.y)); y++) {
          path.push({ x: p.floor(muxOutput.x), y });
        }
        for (let y = p.floor(p.min(outputJunction.y, outputPad.y)); y <= p.floor(p.max(outputJunction.y, outputPad.y)); y++) {
          path.push({ x: p.floor(outputJunction.x), y });
        }
        for (let x = p.floor(p.min(outputJunction.x, outputPad.x)); x <= p.floor(p.max(outputJunction.x, outputPad.x)); x++) {
          path.push({ x, y: p.floor(outputPad.y) });
        }
        return path;
      }
    };

    new p5(sketch, document.body);
  </script>
</body>

</html>