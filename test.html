<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Beach Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #f0f0f0;
    }
  </style>
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
      }
    }
  </script>
</head>
<body>
  <script type="module">
    import p5 from 'p5';
    const sketch = (p) => {
      const particles = [];
      const wetCells = {};
      const resolution = 20;
      const wetDecayRate = 0.98;

      let shorelinePoints = [];
      let waveOffset = 0;
      let wavePeakOffset = 0;

      p.setup = () => {
        p.createCanvas(p.windowWidth, p.windowHeight);
        p.noiseSeed(p.random(10000));
        generateShoreline();
        for (let i = 0; i < 200; i++) {
          particles.push(new Particle(
            p.random(p.width), p.random(p.height / 2, p.height),
            p.random(4, 8), p.random(0.5, 1.5)
          ));
        }
        p.frameRate(30);
      };

      function generateShoreline() {
        shorelinePoints = [];
        const baseY = p.height * 0.65;
        const amplitude = p.height * 0.05;
        for (let x = 0; x < p.width; x += resolution) {
          const n = p.noise(x * 0.005);
          const y = baseY + p.map(n, 0, 1, -amplitude, amplitude);
          shorelinePoints.push({ x, y });
        }
      }

      class Particle {
        constructor(x, y, size, weight) {
          this.x = x; this.y = y;
          this.size = size; this.weight = weight;
          this.color = p.color(255, 240, 200);
          this.velX = 0; this.velY = 0;
          this.beenPushed = false;
        }
        update() {
          this.x += this.velX; this.y += this.velY;
          this.velX *= 0; this.velY *= 0;
          if (this.y < 0) this.y = 0;
          const sp = getShorelinePoint(this.x);
          if (this.y > sp.y) this.y = sp.y;
          const cell = `${Math.floor(this.x / resolution)},${Math.floor(this.y / resolution)}`;
          if (wetCells[cell] > 0.2) {
            const pushX = p.random(-1, 1) * wetCells[cell] * 3;
            const pushY = p.random(-1, 0) * wetCells[cell] * 2;
            this.velX = pushX / this.weight;
            this.velY = pushY / this.weight;
          }
        }
        show() {
          p.fill(this.color);
          p.noStroke();
          p.ellipse(this.x, this.y, this.size);
        }
      }

      function getShorelinePoint(x) {
        let seg = Math.floor(x / resolution);
        if (seg >= shorelinePoints.length - 1) seg = shorelinePoints.length - 2;
        const p1 = shorelinePoints[seg];
        const p2 = shorelinePoints[seg + 1];
        const t = (x - p1.x) / (p2.x - p1.x);
        return { x, y: p.lerp(p1.y, p2.y, t) };
      }

      p.draw = () => {
        p.background(135, 206, 235);

        const waveY = p.height * 0.15;
        p.noFill();
        p.stroke(255, 255, 255, 180);
        p.strokeWeight(2);
        p.beginShape();
        for (let x = 0; x <= p.width; x += 10) {
          const waveAmp = p.sin(x * 0.02 + waveOffset) * 15;
          p.vertex(x, waveY + waveAmp);
        }
        p.endShape();

        waveOffset += 0.05;
        wavePeakOffset += 0.03;

        for (let i = 0; i < shorelinePoints.length - 1; i++) {
          const p1 = shorelinePoints[i];
          const p2 = shorelinePoints[i + 1];
          p.fill(194, 178, 128);
          p.noStroke();
          p.beginShape();
          p.vertex(p1.x, p.height);
          p.vertex(p2.x, p.height);
          p.vertex(p2.x, p2.y);
          p.vertex(p1.x, p1.y);
          p.endShape(p.CLOSE);
        }

        for (let x = 0; x < p.width; x += resolution) {
          const waveAmp = p.sin(x * 0.02 + waveOffset) * 15;
          const waveBase = p.height * 0.15 + waveAmp;
          const waveBottom = waveBase + 20;
          const sp = getShorelinePoint(x);
          if (waveBottom >= sp.y && waveBase < sp.y) {
            const cell = `${Math.floor(x / resolution)},${Math.floor(sp.y / resolution)}`;
            wetCells[cell] = (wetCells[cell] || 0) + 0.3;
          }
        }

        for (const cell in wetCells) {
          wetCells[cell] *= wetDecayRate;
          if (wetCells[cell] < 0.05) delete wetCells[cell];
        }

        const wetCanvas = p.createGraphics(p.width, p.height);
        wetCanvas.noStroke();
        for (const cell in wetCells) {
          const [cx, cy] = cell.split(',').map(Number);
          const x = cx * resolution;
          const y = cy * resolution;
          wetCanvas.fill(60, 60, 60, wetCells[cell] * 255);
          wetCanvas.rect(x, y, resolution, resolution);
        }
        p.image(wetCanvas, 0, 0);

        for (const p of particles) {
          p.update();
          p.show();
        }
      };

      p.windowResized = () => {
        p.resizeCanvas(p.windowWidth, p.windowHeight);
        generateShoreline();
      };
    };
    new p5(sketch);
  </script>
</body>
</html>