<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2D Physics Simulation</title>
  <script type="importmap">
    {
      "imports": {
        "p5": "https://esm.sh/p5@1.9.4"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #202030; /* Darker background */
      font-family: Arial, sans-serif;
      overflow: hidden; /* Prevent scrollbars */
    }
    .container {
      position: relative;
      width: 800px;
      height: 600px;
      border: 2px solid #444;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }
    .reset-button {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      padding: 8px 12px;
      font-size: 14px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }
    .reset-button:hover {
      background-color: #2980b9;
    }
  </style>
</head>
<body>
  <div class="container">
    <button class="reset-button" id="resetButton">Reset</button>
  </div>
  
  <script type="module">
    import p5 from 'p5';
    
    /**
     * Main sketch function for the magnet maze simulation.
     * Creates a physics simulation where a hexagonal metal puck is attracted to magnets
     * through a maze with walls.
     * @param {p5} p - The p5.js instance.
     */
    const sketch = (p) => {
      // --- Constants ---
      const GRID_SIZE = 50; // Size of each grid cell in pixels
      const PUCK_RADIUS = 18; // Radius of the hexagonal puck
      const MAGNET_SIZE = 8; // Visual size of magnets
      const WALL_THICKNESS = 4; // Thickness of maze walls
      const MAZE_WIDTH = 16; // Width of maze in grid cells
      const MAZE_HEIGHT = 12; // Height of maze in grid cells
      const TIMESTEP = 0.5; // Physics timestep delta (arbitrary units)
      
      // Maze layout (1 = wall, 0 = empty space)
      const mazeLayout = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      ];
      
      // --- Variables ---
      let puck; // The metal puck object
      let magnets = []; // Array of magnet objects
      let walls = []; // Array of wall segment objects
      let goalMagnet; // The final magnet to reach
      let startPos; // Starting position of the puck
      let gameStarted = false; // Has the user started the simulation?
      let gameOver = false; // Has the puck reached the goal?
      let message = "Click to Start"; // Message to display
      let canvas; // p5 canvas reference
      
      // --- Magnet Zone Definitions ---
      // Format: [x, y, w, h, forceMultiplier] - Defines rectangular areas with magnetic field strength
      const magnetZones = [
        [2, 2, 3, 3, 1.5],  // Zone 1: Stronger attraction
        [10, 2, 3, 3, 2.0], // Zone 2: Even stronger
        [2, 8, 3, 3, 1.2],  // Zone 3: Weaker
        [10, 8, 3, 3, 1.8]  // Zone 4: Strong
      ];
      
      /**
       * Creates a new puck object with physics properties.
       * @param {number} x - Initial x position.
       * @param {number} y - Initial y position.
       * @returns {Object} Puck object with position, velocity, etc.
       */
      function createPuck(x, y) {
        return {
          x: x,
          y: y,
          vx: 0, // Velocity x
          vy: 0, // Velocity y
          radius: PUCK_RADIUS,
          mass: 1, // Mass (affects acceleration)
          angle: 0, // Visual rotation angle
          trail: [], // Stores positions for trail effect
          trailLength: 20 // Number of positions to remember
        };
      }
      
      /**
       * Creates a new magnet object.
       * @param {number} x - Magnet x position.
       * @param {number} y - Magnet y position.
       * @param {number} [force=1] - Attraction force strength.
       * @param {boolean} [isGoal=false] - Whether this is the goal magnet.
       * @returns {Object} Magnet object.
       */
      function createMagnet(x, y, force = 1, isGoal = false) {
        return {
          x: x,
          y: y,
          force: force, // How strongly it attracts
          isGoal: isGoal // Whether this magnet ends the game
        };
      }
      
      /**
       * Creates wall segments based on the maze layout.
       * @returns {Array<Object>} Array of wall segment objects.
       */
      function createWalls() {
        const wallSegments = [];
        for (let row = 0; row < MAZE_HEIGHT; row++) {
          for (let col = 0; col < MAZE_WIDTH; col++) {
            if (mazeLayout[row][col] === 1) { // If this cell is a wall
              const wallX = col * GRID_SIZE;
              const wallY = row * GRID_SIZE;
              // Add horizontal walls (check right neighbor)
              if (col < MAZE_WIDTH - 1 && mazeLayout[row][col + 1] === 1) {
                wallSegments.push({
                  x1: wallX + GRID_SIZE/2, y1: wallY,
                  x2: wallX + GRID_SIZE*1.5, y2: wallY,
                  normalX: 0, normalY: -1 // Normal vector points up
                });
              }
              // Add vertical walls (check bottom neighbor)
              if (row < MAZE_HEIGHT - 1 && mazeLayout[row + 1][col] === 1) {
                wallSegments.push({
                  x1: wallX, y1: wallY + GRID_SIZE/2,
                  x2: wallX, y2: wallY + GRID_SIZE*1.5,
                  normalX: -1, normalY: 0 // Normal vector points left
                });
              }
            }
          }
        }
        return wallSegments;
      }
      
      /**
       * p5.js setup function - runs once at the beginning.
       * Initializes canvas, maze elements, and event listeners.
       */
      p.setup = () => {
        // Create canvas inside the container
        const container = document.querySelector('.container');
        const width = container.clientWidth;
        const height = container.clientHeight;
        canvas = p.createCanvas(width, height);
        canvas.parent('container'); // Attach canvas to the container
        
        // Initialize maze elements
        walls = createWalls();
        
        // Add frame for the maze
        walls.push(
          { x1: 0, y1: 0, x2: MAZE_WIDTH * GRID_SIZE, y2: 0, normalX: 0, normalY: -1 }, // Top
          { x1: 0, y1: 0, x2: 0, y2: MAZE_HEIGHT * GRID_SIZE, normalX: -1, normalY: 0 }, // Left
          { x1: MAZE_WIDTH * GRID_SIZE, y1: 0, x2: MAZE_WIDTH * GRID_SIZE, y2: MAZE_HEIGHT * GRID_SIZE, normalX: 1, normalY: 0 }, // Right
          { x1: 0, y1: MAZE_HEIGHT * GRID_SIZE, x2: MAZE_WIDTH * GRID_SIZE, y2: MAZE_HEIGHT * GRID_SIZE, normalX: 0, normalY: 1 } // Bottom
        );
        
        // Create magnets (positions in grid coordinates)
        magnets.push(createMagnet(2, 2, 1));    // Magnet 1
        magnets.push(createMagnet(10, 2, 1));   // Magnet 2
        magnets.push(createMagnet(2, 8, 1));    // Magnet 3
        goalMagnet = createMagnet(12, 10, 1, true); // Goal Magnet (ends game)
        magnets.push(goalMagnet);
        
        // Create puck at starting position
        startPos = { x: 4 * GRID_SIZE, y: 6 * GRID_SIZE };
        puck = createPuck(startPos.x, startPos.y);
        
        // Add mouse press event listener
        p.canvas.addEventListener('click', () => {
          if (!gameStarted && !gameOver) {
            gameStarted = true;
            message = "Navigating...";
          }
        });
        
        // Add reset button event listener
        document.getElementById('resetButton').addEventListener('click', resetSimulation);
      };
      
      /**
       * Resets the simulation to its initial state.
       */
      function resetSimulation() {
        puck = createPuck(startPos.x, startPos.y);
        gameStarted = false;
        gameOver = false;
        message = "Click to Start";
      }
      
      /**
       * Handles physics and game logic updates.
       */
      function update() {
        if (gameStarted && !gameOver) {
          // Apply forces from each magnet
          for (let magnet of magnets) {
            let dx = magnet.x * GRID_SIZE - puck.x;
            let dy = magnet.y * GRID_SIZE - puck.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            
            // Check if puck is within a magnet zone
            let zoneForceMultiplier = 1; // Default force multiplier
            for (let zone of magnetZones) {
              // If puck is inside this zone
              if (puck.x > zone[0] * GRID_SIZE && puck.x < (zone[0] + zone[2]) * GRID_SIZE &&
                  puck.y > zone[1] * GRID_SIZE && puck.y < (zone[1] + zone[3]) * GRID_SIZE) {
                zoneForceMultiplier = zone[4]; // Apply zone's force multiplier
                break; // Only apply one zone's effect
              }
            }
            
            // Apply magnetic force (inverse square law)
            if (distance > 0) { // Prevent division by zero
              let force = (magnet.force * zoneForceMultiplier) / (distance * distance);
              // Cap force to prevent extreme acceleration
              force = Math.min(force, 0.2);
              puck.vx += force * dx / distance;
              puck.vy += force * dy / distance;
            }
          }
          
          // Apply damping/friction
          puck.vx *= 0.98;
          puck.vy *= 0.98;
          
          // Update position based on velocity
          puck.x += puck.vx * TIMESTEP;
          puck.y += puck.vy * TIMESTEP;
          
          // Update visual rotation based on velocity
          if (puck.vx !== 0 || puck.vy !== 0) {
            puck.angle = Math.atan2(puck.vy, puck.vx);
          }
          
          // Add current position to trail
          puck.trail.push({ x: puck.x, y: puck.y });
          if (puck.trail.length > puck.trailLength) {
            puck.trail.shift(); // Remove oldest position
          }
          
          // Check for collision with walls
          for (let wall of walls) {
            let collision = checkWallCollision(
              wall.x1, wall.y1, wall.x2, wall.y2,
              puck.x, puck.y, puck.radius
            );
            if (collision) {
              // Apply impulse to reflect velocity
              let dot = puck.vx * collision.normalX + puck.vy * collision.normalY;
              puck.vx -= 2 * dot * collision.normalX;
              puck.vy -= 2 * dot * collision.normalY;
              // Position correction to prevent sticking
              puck.x += collision.normalX * collision.penetration * 1.1;
              puck.y += collision.normalY * collision.penetration * 1.1;
            }
          }
          
          // Check if puck reached the goal magnet
          let dx = goalMagnet.x * GRID_SIZE - puck.x;
          let dy = goalMagnet.y * GRID_SIZE - puck.y;
          let distanceToGoal = Math.sqrt(dx * dx + dy * dy);
          if (distanceToGoal < puck.radius + MAGNET_SIZE) {
            gameOver = true;
            message = "Goal Reached!";
          }
        }
      }
      
      /**
       * Checks for collision between a wall segment and the puck.
       * @param {number} wallX1 - Wall start x coordinate.
       * @param {number} wallY1 - Wall start y coordinate.
       * @param {number} wallX2 - Wall end x coordinate.
       * @param {number} wallY2 - Wall end y coordinate.
       * @param {number} puckX - Puck x position.
       * @param {number} puckY - Puck y position.
       * @param {number} puckRadius - Puck radius.
       * @returns {Object|boolean} Collision data or false if no collision.
       */
      function checkWallCollision(wallX1, wallY1, wallX2, wallY2, puckX, puckY, puckRadius) {
        // Vector from wall start to puck
        let dx = puckX - wallX1;
        let dy = puckY - wallY1;
        
        // Wall segment vector
        let wallDx = wallX2 - wallX1;
        let wallDy = wallY2 - wallY1;
        let wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
        
        // Normalize wall vector
        let normWallDx = wallDx / wallLength;
        let normWallDy = wallDy / wallLength;
        
        // Project puck onto the wall to find closest point
        let projection = dx * normWallDx + dy * normWallDy;
        projection = Math.max(0, Math.min(wallLength, projection));
        
        // Closest point on wall to the puck
        let closestX = wallX1 + projection * normWallDx;
        let closestY = wallY1 + projection * normWallDy;
        
        // Distance from puck to closest point
        let distX = puckX - closestX;
        let distY = puckY - closestY;
        let distance = Math.sqrt(distX * distX + distY * distY);
        
        // Check if distance is less than puck radius
        if (distance < puckRadius) {
          // Normal vector points from wall to puck
          let normalX = distX / distance;
          let normalY = distY / distance;
          
          return {
            normalX: normalX,
            normalY: normalY,
            penetration: puckRadius - distance // How far puck penetrates wall
          };
        }
        return false; // No collision
      }
      
      /**
       * p5.js draw function - called repeatedly to render the simulation.
       */
      p.draw = () => {
        update(); // Update physics and game state
        
        // Draw background
        p.background(20);
        
        // Draw grid lines
        p.stroke(30);
        p.strokeWeight(1);
        for (let x = 0; x <= MAZE_WIDTH * GRID_SIZE; x += GRID_SIZE) {
          p.line(x, 0, x, MAZE_HEIGHT * GRID_SIZE);
        }
        for (let y = 0; y <= MAZE_HEIGHT * GRID_SIZE; y += GRID_SIZE) {
          p.line(0, y, MAZE_WIDTH * GRID_SIZE, y);
        }
        
        // Draw walls
        p.stroke(80, 120, 200, 100); // Blue-gray with transparency
        p.strokeWeight(WALL_THICKNESS);
        for (let wall of walls) {
          p.line(wall.x1, wall.y1, wall.x2, wall.y2);
        }
        
        // Draw magnet zones
        p.noStroke();
        p.fill(255, 255, 0, 30); // Yellow with transparency
        for (let zone of magnetZones) {
          p.rect(
            zone[0] * GRID_SIZE, 
            zone[1] * GRID_SIZE, 
            zone[2] * GRID_SIZE, 
            zone[3] * GRID_SIZE
          );
        }
        
        // Draw magnets
        for (let magnet of magnets) {
          if (magnet.isGoal) {
            // Goal magnet - green
            p.fill(0, 200, 100);
            p.stroke(0, 250, 150);
          } else {
            // Regular magnets - blue
            p.fill(100, 150, 255);
            p.stroke(150, 200, 255);
          }
          p.strokeWeight(2);
          p.ellipse(magnet.x * GRID_SIZE, magnet.y * GRID_SIZE, MAGNET_SIZE * 2);
          // Add highlight for 3D effect
          p.fill(255, 255, 255, 100);
          p.ellipse(
            magnet.x * GRID_SIZE - MAGNET_SIZE/2, 
            magnet.y * GRID_SIZE - MAGNET_SIZE/2, 
            MAGNET_SIZE
          );
        }
        
        // Draw puck trail
        p.noFill();
        p.stroke(255, 100, 100, 80); // Red with transparency
        p.strokeWeight(2);
        p.beginShape();
        for (let pos of puck.trail) {
          p.vertex(pos.x, pos.y);
        }
        p.endShape();
        
        // Draw puck (hexagon)
        p.push(); // Save current transformation
        p.translate(puck.x, puck.y);
        p.rotate(puck.angle);
        
        if (gameOver) {
          // Confetti and celebration colors
          const colors = [
            [255, 100, 100], [100, 255, 100], [100, 100, 255],
            [255, 255, 100], [255, 100, 255], [100, 255, 255]
          ];
          for (let i = 0; i < 12; i++) {
            let r = p.random(2, 5);
            let x = p.cos(p.TWO_PI / 12 * i) * r * 10;
            let y = p.sin(p.TWO_PI / 12 * i) * r * 10;
            let c = p.random(colors);
            p.fill(c[0], c[1], c[2], 150);
            p.noStroke();
            p.ellipse(x, y, r * 3);
          }
        }
        
        // Draw hexagon shape
        p.fill(180, 50, 50); // Reddish metal
        p.stroke(240, 120, 120); // Highlight
        p.strokeWeight(2);
        p.beginShape();
        for (let i = 0; i < 6; i++) {
          let angle = p.TWO_PI / 6 * i;
          let x = p.cos(angle) * puck.radius;
          let y = p.sin(angle) * puck.radius;
          p.vertex(x, y);
        }
        p.endShape(p.CLOSE);
        
        // Add highlight reflection
        p.fill(255, 255, 255, 60);
        p.noStroke();
        p.beginShape();
        for (let i = 0; i < 3; i++) {
          let angle = p.TWO_PI / 6 * i;
          let x = p.cos(angle) * puck.radius * 0.5;
          let y = p.sin(angle) * puck.radius * 0.5;
          p.vertex(x, y);
        }
        p.endShape(p.CLOSE);
        
        p.pop(); // Restore transformation
        
        // Draw UI text
        p.fill(255);
        p.noStroke();
        p.textSize(14);
        p.textAlign(p.CENTER, p.TOP);
        p.text(message, p.width / 2, 10);
        
        // Draw controls hint
        p.textSize(12);
        p.textAlign(p.CENTER, p.BOTTOM);
        p.text("Click anywhere to start • Click Reset to retry", p.width / 2, p.height - 10);
      };
      
      /**
       * Handles window resize events to keep the canvas responsive.
       */
      p.windowResized = () => {
        const container = document.querySelector('.container');
        p.resizeCanvas(container.clientWidth, container.clientHeight);
      };
    };
    
    // Create the p5 instance
    new p5(sketch);
  </script>
</body>
</html>