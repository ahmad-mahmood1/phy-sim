<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wind Glide Game</title>
    <script type="importmap">
        {
          "imports": {
            "p5": "https://cdn.jsdelivr.net/npm/p5@1.11.3/lib/p5.min.js"
          }
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <script type="module">
        import 'p5';

        /**
         * @param {p5} p - The p5.js instance.
         */
        let sketch = function(p) {
            /** @type {Glider} */
            let glider;
            /** @type {Array<Obstacle>} */
            let obstacles = [];
            /** @type {number} */
            let score = 0;
            /** @type {boolean} */
            let gameOver = false;
            /** @type {boolean} */
            let gameStarted = false;
            /** @type {number} */
            let windStrength = 0;
            /** @type {number} */
            let windTimer = 0;
            /** @type {number} */
            let obstacleTimer = 0;
            /** @type {number} */
            let canopyHeight = 150;
            /** @type {number} */
            let groundHeight = 100;
            /** @type {p5.Font | null} */
            let font;
            /** @type {number} */
            let fontSize = 32;

            /**
             * @typedef {Object} Glider
             * @property {number} x - The x-coordinate of the glider.
             * @property {number} y - The y-coordinate of the glider.
             * @property {number} velocityY - The vertical velocity of the glider.
             * @property {number} size - The size of the glider.
             * @property {p5.Color} color - The color of the glider.
             */

            /**
             * @typedef {Object} Obstacle
             * @property {number} x - The x-coordinate of the obstacle.
             * @property {number} y - The y-coordinate of the obstacle.
             * @property {number} size - The size of the obstacle.
             * @property {p5.Color} color - The color of the obstacle.
             * @property {number} gapSize - The size of the gap in the obstacle.
             * @property {number} topHeight - The height of the top part of the obstacle.
             */

            /**
             * Creates a new Glider instance.
             * @returns {Glider} The created glider.
             */
            function createGlider() {
                return {
                    x: p.width / 4,
                    y: p.height / 2,
                    velocityY: 0,
                    size: 40,
                    color: p.color(255, 100, 100)
                };
            }

            /**
             * Creates a new Obstacle instance.
             * @param {number} x - The x-coordinate of the obstacle.
             * @param {number} height - The height of the canvas.
             * @returns {Obstacle} The created obstacle.
             */
            function createObstacle(x, height) {
                const gapSize = p.random(60, 120);
                const availableHeight = height - canopyHeight - groundHeight - gapSize;
                const topHeight = p.random(20, availableHeight - 20);
                return {
                    x: x,
                    y: canopyHeight + topHeight,
                    size: 40,
                    color: p.color(100, 255, 100),
                    gapSize: gapSize,
                    topHeight: topHeight
                };
            }

            /**
             * Handles user input for the glider.
             */
            function handleInput() {
                if (p.keyIsDown(p.UP_ARROW)) {
                    glider.velocityY -= 0.2;
                }
                if (p.keyIsDown(p.DOWN_ARROW)) {
                    glider.velocityY += 0.2;
                }
            }

            /**
             * Updates the glider's position and physics.
             */
            function updateGlider() {
                glider.velocityY += 0.05; // Gravity
                glider.velocityY *= 0.98; // Air resistance
                glider.y += glider.velocityY;

                // Wind effect
                glider.y += windStrength * 0.1;

                // Keep glider within bounds
                if (glider.y < canopyHeight + glider.size / 2) {
                    glider.y = canopyHeight + glider.size / 2;
                    glider.velocityY = 0;
                }
                if (glider.y > p.height - groundHeight - glider.size / 2) {
                    glider.y = p.height - groundHeight - glider.size / 2;
                    glider.velocityY = 0;
                }
            }

            /**
             * Updates the obstacles' positions and generates new ones.
             */
            function updateObstacles() {
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    obstacles[i].x -= 2;
                    if (obstacles[i].x < -obstacles[i].size) {
                        obstacles.splice(i, 1);
                        score++;
                    }
                }

                obstacleTimer++;
                if (obstacleTimer > 120) {
                    obstacles.push(createObstacle(p.width, p.height));
                    obstacleTimer = 0;
                }
            }

            /**
             * Changes the wind strength at random intervals.
             */
            function updateWind() {
                windTimer++;
                if (windTimer > p.random(300, 600)) {
                    windStrength = p.random(-2, 2);
                    windTimer = 0;
                }
            }

            /**
             * Checks for collisions between the glider and obstacles.
             */
            function checkCollisions() {
                for (let obstacle of obstacles) {
                    if (glider.x + glider.size / 2 > obstacle.x &&
                        glider.x - glider.size / 2 < obstacle.x + obstacle.size) {
                        // Check if glider is in the gap
                        if (!(glider.y - glider.size / 2 > obstacle.y &&
                            glider.y + glider.size / 2 < obstacle.y + obstacle.gapSize)) {
                            gameOver = true;
                        }
                    }
                }
            }

            /**
             * Draws the game canopy.
             */
            function drawCanopy() {
                p.fill(34, 139, 34); // Forest green
                p.noStroke();
                p.rect(0, 0, p.width, canopyHeight);
            }

            /**
             * Draws the game ground.
             */
            function drawGround() {
                p.fill(139, 69, 19); // Saddle brown
                p.noStroke();
                p.rect(0, p.height - groundHeight, p.width, groundHeight);
            }

            /**
             * Draws the wind indicator.
             */
            function drawWindIndicator() {
                p.push();
                p.translate(p.width - 50, 50);
                p.noFill();
                p.stroke(0);
                p.strokeWeight(2);
                p.line(0, 0, windStrength * 10, 0);
                p.triangle(windStrength * 10, 0, windStrength * 10 - 5, 5, windStrength * 10 + 5, 5);
                p.pop();
            }

            /**
             * Draws the glider.
             */
            function drawGlider() {
                p.push();
                p.translate(glider.x, glider.y);
                p.fill(glider.color);
                p.stroke(0);
                p.strokeWeight(1);
                p.triangle(0, -glider.size / 2, 0, glider.size / 2, glider.size, 0);
                p.pop();
            }

            /**
             * Draws the obstacles.
             */
            function drawObstacles() {
                for (let obstacle of obstacles) {
                    p.fill(obstacle.color);
                    p.stroke(0);
                    p.strokeWeight(1);
                    // Draw top part
                    p.rect(obstacle.x, 0, obstacle.size, obstacle.y);
                    // Draw bottom part
                    p.rect(obstacle.x, obstacle.y + obstacle.gapSize, obstacle.size, p.height - (obstacle.y + obstacle.gapSize));
                }
            }

            /**
             * Draws the game UI, including score and game over screen.
             */
            function drawUI() {
                p.fill(0);
                p.textSize(fontSize);
                p.textAlign(p.LEFT);
                p.text(`Score: ${score}`, 20, 40);

                if (gameOver) {
                    p.push();
                    p.fill(255, 0, 0);
                    p.textSize(48);
                    p.textAlign(p.CENTER);
                    p.text("Game Over!", p.width / 2, p.height / 2);
                    p.textSize(24);
                    p.text(`Press SPACE to restart`, p.width / 2, p.height / 2 + 40);
                    p.pop();
                } else if (!gameStarted) {
                    p.push();
                    p.fill(0);
                    p.textSize(36);
                    p.textAlign(p.CENTER);
                    p.text("Wind Glide Game", p.width / 2, p.height / 2 - 60);
                    p.textSize(24);
                    p.text("Use UP and DOWN arrows to navigate", p.width / 2, p.height / 2);
                    p.textSize(20);
                    p.text("Press SPACE to start", p.width / 2, p.height / 2 + 40);
                    p.pop();
                }
            }

            /**
             * p5.js setup function. Initializes the canvas, font, and game state.
             */
            p.setup = function() {
                p.createCanvas(800, 600);
                font = p.loadFont('https://fonts.googleapis.com/css2?family=Roboto&display=swap');
                p.textFont(font);
                fontSize = 32;
                glider = createGlider();
                obstacles = [];
                score = 0;
                gameOver = false;
                gameStarted = false;
                windStrength = 0;
                windTimer = 0;
                obstacleTimer = 0;
            };

            /**
             * p5.js draw function. Called repeatedly to update and render the game.
             */
            p.draw = function() {
                p.background(135, 206, 235); // Sky blue

                if (gameStarted && !gameOver) {
                    handleInput();
                    updateWind();
                    updateGlider();
                    updateObstacles();
                    checkCollisions();
                }

                drawCanopy();
                drawGround();
                drawWindIndicator();
                drawObstacles();
                drawGlider();
                drawUI();
            };

            /**
             * p5.js keyPressed function. Handles keyboard input.
             */
            p.keyPressed = function() {
                if (p.key === ' ' && (gameOver || !gameStarted)) {
                    p.setup(); // Reset game
                    gameStarted = true;
                    gameOver = false;
                }
            };
        };

        let myp5 = new window.p5(sketch);
    </script>
</body>
</html>