<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Voronoi Diagram</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
        }
        canvas {
            display: block;
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            border-radius: 0.5rem;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm",
                "d3-delaunay": "https://cdn.skypack.dev/d3-delaunay"
            }
        }
    </script>
</head>

<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl text-center mb-6">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-800">Interactive Voronoi Diagram</h1>
        <p class="text-gray-600 mt-2">Click and drag the points to stretch and compress the cells.</p>
    </div>

    <div id="canvas-container" class="w-full max-w-4xl aspect-square">
        <!-- p5.js canvas will be inserted here -->
    </div>

    <script type="module">
        import p5 from 'p5';
        import { Delaunay } from 'd3-delaunay';

        const sketch = (p) => {
            let points = [];
            const numPoints = 30; // Number of seed points for the diagram
            let pointColors = [];
            let selectedPointIndex = -1; // -1 means no point is selected
            const pointRadius = 10; // Clickable radius for the points

            // --- Setup ---
            // This function runs once when the program starts.
            p.setup = () => {
                const container = p.select('#canvas-container');
                const canvas = p.createCanvas(container.width, container.height);
                canvas.parent(container);
                p.colorMode(p.HSB, 360, 100, 100); // Use HSB color mode for vibrant colors

                // Generate initial random points and assign a permanent color to each
                for (let i = 0; i < numPoints; i++) {
                    points.push([p.random(p.width), p.random(p.height)]);
                    pointColors.push(p.color(p.random(360), 70, 90));
                }
            };
            
            // --- Window Resized ---
            // Adjust canvas size when the browser window is resized.
            p.windowResized = () => {
                const container = p.select('#canvas-container');
                p.resizeCanvas(container.width, container.height);
            };

            // --- Main Drawing Loop ---
            // This function runs continuously to draw frames.
            p.draw = () => {
                p.background(0, 0, 98); // A very light gray background

                // Calculate the Voronoi diagram from the current points
                // The diagram is bounded by the canvas dimensions.
                const delaunay = Delaunay.from(points);
                const voronoi = delaunay.voronoi([0, 0, p.width, p.height]);
                
                // --- Render Voronoi Cells ---
                p.stroke(0, 0, 20); // Dark gray stroke for cell borders
                p.strokeWeight(2.5);
                let i = 0;
                for (const cell of voronoi.cellPolygons()) {
                    p.fill(pointColors[i]);
                    p.beginShape();
                    for (const [x, y] of cell) {
                        p.vertex(x, y);
                    }
                    p.endShape(p.CLOSE);
                    i++;
                }
                
                // --- Render Seed Points ---
                p.noStroke();
                for (let i = 0; i < points.length; i++) {
                    p.fill(0, 0, 10); // Dark gray for points
                    p.circle(points[i][0], points[i][1], pointRadius);
                }
                
                // --- Handle Mouse Interaction Cues ---
                const hoveringIndex = getPointUnderMouse();
                if (selectedPointIndex !== -1) {
                    p.cursor('grabbing');
                } else if (hoveringIndex !== -1) {
                    p.cursor('grab');
                    // Add a highlight to the point being hovered over
                    p.fill(0, 0, 100, 0.3); // Semi-transparent white
                    p.circle(points[hoveringIndex][0], points[hoveringIndex][1], pointRadius * 1.5);
                } else {
                    p.cursor(p.ARROW);
                }
            };
            
            // --- Helper function to find which point is under the mouse ---
            const getPointUnderMouse = () => {
                for (let i = 0; i < points.length; i++) {
                    if (p.dist(p.mouseX, p.mouseY, points[i][0], points[i][1]) < pointRadius) {
                        return i;
                    }
                }
                return -1; // Return -1 if no point is found
            };
            
            // --- Mouse Press Event ---
            p.mousePressed = () => {
                // If the mouse is inside the canvas, check for a point
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    selectedPointIndex = getPointUnderMouse();
                    return false; // Prevent default browser action
                }
            };
            
            // --- Mouse Drag Event ---
            p.mouseDragged = () => {
                if (selectedPointIndex !== -1) {
                    // Update the position of the selected point, constrained within the canvas
                    const newX = p.constrain(p.mouseX, 0, p.width);
                    const newY = p.constrain(p.mouseY, 0, p.height);
                    points[selectedPointIndex] = [newX, newY];
                }
            };
            
            // --- Mouse Release Event ---
            p.mouseReleased = () => {
                // Deselect the point
                selectedPointIndex = -1;
            };
        };

        // Instantiate p5.js and attach it to the container
        new p5(sketch);

    </script>
</body>

</html>
