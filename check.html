<script type="module">
    import 'p5';

    /**
     * @param {p5} p - The p5.js instance.
     */
    let sketch = function (p) {
        /** @type {number} */
        let numX = 100;
        /** @type {number} */
        let numY = 75;
        /** @type {Array<Array<number>>} */
        let scalarField = new Array(numX);
        /** @type {number} */
        let isoValue = 0.5;
        /** @type {p5.Graphics} */
        let channelGraphics;
        /** @type {number} */
        let time = 0;
        /** @type {number} */
        let timeStep = 0.01;
        /** @type {number} */
        let flowSpeed = 1.0;
        /** @type {number} */
        let noiseScale = 0.1;
        /** @type {Array<Array<number>>} */
        let channelMasks = [];
        /** @type {number} */
        let cellSizeX;
        /** @type {number} */
        let cellSizeY;

        /**
         * Setup function for p5.js. Initializes the canvas, scalar field, and channel graphics.
         */
        p.setup = function () {
            let canvas = p.createCanvas(800, 600);
            canvas.parent('canvas-container');

            cellSizeX = p.width / numX;
            cellSizeY = p.height / numY;

            // Initialize scalar field
            for (let i = 0; i < numX; i++) {
                scalarField[i] = new Array(numY).fill(0);
            }

            // Create an off-screen graphics buffer for the channel network
            channelGraphics = p.createGraphics(p.width, p.height);
            drawChannelNetwork(channelGraphics);

            // --- FIX START ---
            // Sample the graphics buffer to create a binary mask
            // This tells the simulation where the channels are
            channelGraphics.loadPixels(); // Load pixel data for fast access
            for (let j = 0; j < numY; j++) {
                channelMasks[j] = [];
                for (let i = 0; i < numX; i++) {
                    // Check the color at the center of each grid cell
                    const x = Math.floor(i * cellSizeX + cellSizeX / 2);
                    const y = Math.floor(j * cellSizeY + cellSizeY / 2);
                    const index = (y * p.width + x) * 4;

                    // The drawn channel is white, so check the red component.
                    const redValue = channelGraphics.pixels[index];
                    channelMasks[j][i] = (redValue > 0) ? 1 : 0;
                }
            }
            // --- FIX END ---
        };

        /**
         * Draw function for p5.js. Updates and renders the fluid simulation.
         */
        p.draw = function () {
            p.background(32, 32, 48);

            updateScalarField();

            // Optional: Draw the underlying fluid values for debugging or effect
            p.noStroke();
            for (let j = 0; j < numY; j++) {
                for (let i = 0; i < numX; i++) {
                    if (channelMasks[j][i] === 1) {
                        const alpha = p.map(scalarField[i][j], isoValue, 1.2, 0, 50);
                        p.fill(100, 150, 255, alpha);
                        p.rect(i * cellSizeX, j * cellSizeY, cellSizeX, cellSizeY);
                    }
                }
            }

            // Draw the Marching Squares contour lines
            p.stroke(220, 230, 255);
            p.strokeWeight(2.5);
            p.noFill();
            for (let j = 0; j < numY - 1; j++) {
                for (let i = 0; i < numX - 1; i++) {
                    // Only draw contours inside the channel network
                    if (channelMasks[j][i] === 1) {
                        let topLeft = scalarField[i][j];
                        let topRight = scalarField[i + 1][j];
                        let bottomLeft = scalarField[i][j + 1];
                        let bottomRight = scalarField[i + 1][j + 1];

                        drawContour(i, j, topLeft, topRight, bottomLeft, bottomRight);
                    }
                }
            }

            time += timeStep;
        };

        /**
         * Calculates and draws a line segment for a single cell based on the Marching Squares algorithm.
         */
        function drawContour(i, j, v1, v2, v3, v4) {
            let caseIndex = 0;
            if (v1 > isoValue) caseIndex |= 8; // Top-left
            if (v2 > isoValue) caseIndex |= 4; // Top-right
            if (v4 > isoValue) caseIndex |= 2; // Bottom-right
            if (v3 > isoValue) caseIndex |= 1; // Bottom-left

            const x = i * cellSizeX;
            const y = j * cellSizeY;

            // Interpolation helper function
            const interp = (val1, val2) => p.abs(isoValue - val1) / p.abs(val2 - val1);

            // Points on the edges of the cell
            const top = { x: x + cellSizeX * interp(v1, v2), y: y };
            const right = { x: x + cellSizeX, y: y + cellSizeY * interp(v2, v4) };
            const bottom = { x: x + cellSizeX * interp(v3, v4), y: y + cellSizeY };
            const left = { x: x, y: y + cellSizeY * interp(v1, v3) };

            switch (caseIndex) {
                case 1: p.line(left.x, left.y, bottom.x, bottom.y); break;
                case 2: p.line(bottom.x, bottom.y, right.x, right.y); break;
                case 3: p.line(left.x, left.y, right.x, right.y); break;
                case 4: p.line(top.x, top.y, right.x, right.y); break;
                case 5: p.line(left.x, left.y, top.x, top.y); p.line(bottom.x, bottom.y, right.x, right.y); break;
                case 6: p.line(top.x, top.y, bottom.x, bottom.y); break;
                case 7: p.line(left.x, left.y, top.x, top.y); break;
                case 8: p.line(left.x, left.y, top.x, top.y); break;
                case 9: p.line(top.x, top.y, bottom.x, bottom.y); break;
                case 10: p.line(top.x, top.y, right.x, right.y); p.line(left.x, left.y, bottom.x, bottom.y); break;
                case 11: p.line(top.x, top.y, right.x, right.y); break;
                case 12: p.line(left.x, left.y, right.x, right.y); break;
                case 13: p.line(bottom.x, bottom.y, right.x, right.y); break;
                case 14: p.line(left.x, left.y, bottom.x, bottom.y); break;
            }
        }


        /**
         * Updates the scalar field using Perlin noise to simulate fluid flow.
         */
        function updateScalarField() {
            for (let i = 0; i < numX; i++) {
                for (let j = 0; j < numY; j++) {
                    if (channelMasks[j][i] === 1) {
                        let noiseVal = p.noise(
                            i * noiseScale + time * flowSpeed,
                            j * noiseScale,
                            time * flowSpeed * 0.5 // A third dimension to make it dynamic
                        );
                        scalarField[i][j] = noiseVal;
                    } else {
                        scalarField[i][j] = 0; // Set values outside channel to 0
                    }
                }
            }
        }

        /**
         * Draws the channel network onto a graphics buffer.
         * @param {p5.Graphics} pg - The graphics buffer to draw on.
         */
        function drawChannelNetwork(pg) {
            pg.background(0); // Black background
            pg.stroke(255);   // White stroke for the channels
            pg.strokeWeight(30); // Make channels thicker for better sampling
            pg.noFill();

            // Central channel
            pg.line(40, 300, 760, 300);

            // Branching structures
            for (let i = 0; i < 5; i++) {
                let x = 150 + i * 120;
                pg.line(x, 300, x, 100);
                pg.line(x, 300, x, 500);

                pg.line(x - 40, 100, x + 40, 100);
                pg.line(x - 40, 500, x + 40, 500);
            }
        }
    };

    let myp5 = new window.p5(sketch);
</script>
